import { BytesLike } from '@ethersproject/bytes';
import { Bech32Address, B256Address, AddressLike, ContractIdLike, AbstractAddress } from '@fuel-ts/interfaces';
import { Decoded } from 'bech32';

declare const FUEL_BECH32_HRP_PREFIX = "fuel";
/**
 * Decodes a Bech32 address string into Decoded
 */
declare function fromBech32(address: Bech32Address): Decoded;
/**
 * Converts a B256 address string into Bech32
 */
declare function toBech32(address: B256Address): Bech32Address;
/**
 * Determines if a given string is Bech32 format
 */
declare function isBech32(address: BytesLike): boolean;
/**
 * Determines if a given string is B256 format
 */
declare function isB256(address: string): boolean;
/**
 * Determines if a given string is in Public Key format (512 bits)
 */
declare function isPublicKey(address: string): boolean;
/**
 * Takes a Bech32 address and returns the byte data
 */
declare function getBytesFromBech32(address: Bech32Address): Uint8Array;
/**
 * Converts a Bech32 address string into B256
 */
declare function toB256(address: Bech32Address): B256Address;
/**
 * Takes a Bech32 address and returns a normalized (i.e. lower case) representation of it.
 *
 * The input is validated along the way, which makes this significantly safer than
 * using `address.toLowerCase()`.
 */
declare function normalizeBech32(address: Bech32Address): Bech32Address;
declare const addressify: (addressLike: AddressLike | ContractIdLike) => AbstractAddress;
declare const getRandomB256: () => string;

declare class Address extends AbstractAddress {
    readonly bech32Address: Bech32Address;
    constructor(address: Bech32Address);
    /**
     * @returns This address as a Bech32m string
     */
    toAddress(): Bech32Address;
    /**
     * @returns This address as 256 bit hash string
     */
    toB256(): B256Address;
    /**
     * @returns Returns this address as a byte array
     */
    toBytes(): Uint8Array;
    /**
     * @returns This address as hexed 256 bit hash string
     */
    toHexString(): B256Address;
    /**
     * Prints this Address value
     * @returns a string address in Bech32m Format
     */
    toString(): string;
    /**
     * Parses this Address value
     * @returns a string address in Bech32m Format
     */
    toJSON(): string;
    /**
     * Returns the value of this Address value
     * @returns a string address in Bech32m Format
     */
    valueOf(): string;
    /**
     * Compare this Address value to another for direct equality
     * @param other - the other address to compare against
     * @returns true if addresses are equal
     */
    equals(other: Address): boolean;
    /**
     * Takes a Public Key, hashes it, and creates an Address
     * @param publicKey - the wallets public key
     * @returns a new `Address` instance
     */
    static fromPublicKey(publicKey: string): Address;
    /**
     * Takes a B256Address and creates an Address
     * @param b256Address - the b256 hash
     * @returns a new `Address` instance
     */
    static fromB256(b256Address: string): Address;
    /**
     * Creates a random address within an Address
     * @returns a new `Address` instance
     */
    static fromRandom(): Address;
    /**
     * Takes an ambiguous string and attempts to create an Address
     * @returns a new `Address` instance
     */
    static fromString(address: string): Address;
    /**
     * Takes an ambiguous string or address and creates an address
     * @returns a new `Address` instance
     */
    static fromAddressOrString(address: string | AbstractAddress): AbstractAddress;
    /**
     * Takes an optional string and returns back an Address
     *
     * @param addressId - Can be a string containing Bech32, B256, or Public Key
     * @throws Error
     * thrown if the input string is not nilsy and cannot be resolved to a valid address format
     * @returns a new `Address` instance
     */
    static fromDynamicInput(address: string | AbstractAddress): Address;
}

export { Address, FUEL_BECH32_HRP_PREFIX, addressify, fromBech32, getBytesFromBech32, getRandomB256, isB256, isBech32, isPublicKey, normalizeBech32, toB256, toBech32 };
