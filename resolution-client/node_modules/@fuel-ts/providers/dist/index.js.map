{"version":3,"sources":["../src/index.ts","../src/coin-quantity.ts","../src/__generated__/operations.ts","../src/provider.ts","../src/resource.ts","../src/transaction-request/input.ts","../src/transaction-request/output.ts","../src/transaction-request/transaction-request.ts","../src/utils/receipts.ts","../src/utils/fee.ts","../src/utils/block-explorer.ts","../src/utils/json.ts","../src/utils/sleep.ts","../src/transaction-request/storage-slot.ts","../src/transaction-request/witness.ts","../src/transaction-response/transaction-response.ts","../src/transaction-response/getDecodedLogs.ts"],"sourcesContent":["/// <reference types=\"graphql\" />\n\nexport * from './coin-quantity';\nexport * from './coin';\nexport * from './provider';\nexport * from './message';\nexport * from './resource';\nexport { default as Provider } from './provider';\nexport * from './transaction-request';\nexport * from './transaction-response';\nexport * from './utils';\n","import type { BytesLike } from '@ethersproject/bytes';\nimport { hexlify } from '@ethersproject/bytes';\nimport { NativeAssetId } from '@fuel-ts/address/configs';\nimport type { BigNumberish, BN } from '@fuel-ts/math';\nimport { bn } from '@fuel-ts/math';\n\nexport type CoinQuantityLike =\n  | [amount: BigNumberish, assetId?: BytesLike, max?: BigNumberish]\n  | { amount: BigNumberish; assetId?: BytesLike; max?: BigNumberish };\nexport type CoinQuantity = { amount: BN; assetId: string; max?: BN };\n\nexport const coinQuantityfy = (coinQuantityLike: CoinQuantityLike): CoinQuantity => {\n  let assetId;\n  let amount;\n  let max;\n  if (Array.isArray(coinQuantityLike)) {\n    amount = coinQuantityLike[0];\n    assetId = coinQuantityLike[1] ?? NativeAssetId;\n    max = coinQuantityLike[2] ?? undefined;\n  } else {\n    amount = coinQuantityLike.amount;\n    assetId = coinQuantityLike.assetId ?? NativeAssetId;\n    max = coinQuantityLike.max ?? undefined;\n  }\n\n  return {\n    assetId: hexlify(assetId),\n    amount: bn(amount),\n    max: max ? bn(max) : undefined,\n  };\n};\n","import type { GraphQLClient } from 'graphql-request';\nimport type * as Dom from 'graphql-request/dist/types.dom';\nimport gql from 'graphql-tag';\n\nexport type Maybe<T> = T | null;\nexport type InputMaybe<T> = Maybe<T>;\nexport type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };\nexport type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };\nexport type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };\n/** All built-in and custom scalars, mapped to their actual values */\nexport type Scalars = {\n  ID: string;\n  String: string;\n  Boolean: boolean;\n  Int: number;\n  Float: number;\n  Address: string;\n  AssetId: string;\n  BlockId: string;\n  Bytes32: string;\n  ContractId: string;\n  HexString: string;\n  MessageId: any;\n  Salt: string;\n  Signature: any;\n  Tai64Timestamp: any;\n  TransactionId: string;\n  TxPointer: any;\n  U64: string;\n  UtxoId: string;\n};\n\nexport type GqlBalance = {\n  __typename: 'Balance';\n  amount: Scalars['U64'];\n  assetId: Scalars['AssetId'];\n  owner: Scalars['Address'];\n};\n\nexport type GqlBalanceConnection = {\n  __typename: 'BalanceConnection';\n  /** A list of edges. */\n  edges: Array<GqlBalanceEdge>;\n  /** A list of nodes. */\n  nodes: Array<GqlBalance>;\n  /** Information to aid in pagination. */\n  pageInfo: GqlPageInfo;\n};\n\n/** An edge in a connection. */\nexport type GqlBalanceEdge = {\n  __typename: 'BalanceEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge */\n  node: GqlBalance;\n};\n\nexport type GqlBalanceFilterInput = {\n  /** Filter coins based on the `owner` field */\n  owner: Scalars['Address'];\n};\n\nexport type GqlBlock = {\n  __typename: 'Block';\n  consensus: GqlConsensus;\n  header: GqlHeader;\n  id: Scalars['BlockId'];\n  transactions: Array<GqlTransaction>;\n};\n\nexport type GqlBlockConnection = {\n  __typename: 'BlockConnection';\n  /** A list of edges. */\n  edges: Array<GqlBlockEdge>;\n  /** A list of nodes. */\n  nodes: Array<GqlBlock>;\n  /** Information to aid in pagination. */\n  pageInfo: GqlPageInfo;\n};\n\n/** An edge in a connection. */\nexport type GqlBlockEdge = {\n  __typename: 'BlockEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge */\n  node: GqlBlock;\n};\n\nexport type GqlBreakpoint = {\n  contract: Scalars['ContractId'];\n  pc: Scalars['U64'];\n};\n\nexport type GqlChainInfo = {\n  __typename: 'ChainInfo';\n  baseChainHeight: Scalars['U64'];\n  consensusParameters: GqlConsensusParameters;\n  latestBlock: GqlBlock;\n  name: Scalars['String'];\n  peerCount: Scalars['Int'];\n};\n\nexport type GqlChangeOutput = {\n  __typename: 'ChangeOutput';\n  amount: Scalars['U64'];\n  assetId: Scalars['AssetId'];\n  to: Scalars['Address'];\n};\n\nexport type GqlCoin = {\n  __typename: 'Coin';\n  amount: Scalars['U64'];\n  assetId: Scalars['AssetId'];\n  blockCreated: Scalars['U64'];\n  maturity: Scalars['U64'];\n  owner: Scalars['Address'];\n  status: GqlCoinStatus;\n  utxoId: Scalars['UtxoId'];\n};\n\nexport type GqlCoinConnection = {\n  __typename: 'CoinConnection';\n  /** A list of edges. */\n  edges: Array<GqlCoinEdge>;\n  /** A list of nodes. */\n  nodes: Array<GqlCoin>;\n  /** Information to aid in pagination. */\n  pageInfo: GqlPageInfo;\n};\n\n/** An edge in a connection. */\nexport type GqlCoinEdge = {\n  __typename: 'CoinEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge */\n  node: GqlCoin;\n};\n\nexport type GqlCoinFilterInput = {\n  /** Returns coins only with `asset_id`. */\n  assetId?: InputMaybe<Scalars['AssetId']>;\n  /** Returns coins owned by the `owner`. */\n  owner: Scalars['Address'];\n};\n\nexport type GqlCoinOutput = {\n  __typename: 'CoinOutput';\n  amount: Scalars['U64'];\n  assetId: Scalars['AssetId'];\n  to: Scalars['Address'];\n};\n\nexport enum GqlCoinStatus {\n  Spent = 'SPENT',\n  Unspent = 'UNSPENT',\n}\n\nexport type GqlConsensus = GqlGenesis | GqlPoAConsensus;\n\nexport type GqlConsensusParameters = {\n  __typename: 'ConsensusParameters';\n  contractMaxSize: Scalars['U64'];\n  gasPerByte: Scalars['U64'];\n  gasPriceFactor: Scalars['U64'];\n  maxGasPerTx: Scalars['U64'];\n  maxInputs: Scalars['U64'];\n  maxMessageDataLength: Scalars['U64'];\n  maxOutputs: Scalars['U64'];\n  maxPredicateDataLength: Scalars['U64'];\n  maxPredicateLength: Scalars['U64'];\n  maxScriptDataLength: Scalars['U64'];\n  maxScriptLength: Scalars['U64'];\n  maxStorageSlots: Scalars['U64'];\n  maxWitnesses: Scalars['U64'];\n};\n\nexport type GqlContract = {\n  __typename: 'Contract';\n  bytecode: Scalars['HexString'];\n  id: Scalars['ContractId'];\n  salt: Scalars['Salt'];\n};\n\nexport type GqlContractBalance = {\n  __typename: 'ContractBalance';\n  amount: Scalars['U64'];\n  assetId: Scalars['AssetId'];\n  contract: Scalars['ContractId'];\n};\n\nexport type GqlContractBalanceConnection = {\n  __typename: 'ContractBalanceConnection';\n  /** A list of edges. */\n  edges: Array<GqlContractBalanceEdge>;\n  /** A list of nodes. */\n  nodes: Array<GqlContractBalance>;\n  /** Information to aid in pagination. */\n  pageInfo: GqlPageInfo;\n};\n\n/** An edge in a connection. */\nexport type GqlContractBalanceEdge = {\n  __typename: 'ContractBalanceEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge */\n  node: GqlContractBalance;\n};\n\nexport type GqlContractBalanceFilterInput = {\n  /** Filter assets based on the `contractId` field */\n  contract: Scalars['ContractId'];\n};\n\nexport type GqlContractCreated = {\n  __typename: 'ContractCreated';\n  contract: GqlContract;\n  stateRoot: Scalars['Bytes32'];\n};\n\nexport type GqlContractOutput = {\n  __typename: 'ContractOutput';\n  balanceRoot: Scalars['Bytes32'];\n  inputIndex: Scalars['Int'];\n  stateRoot: Scalars['Bytes32'];\n};\n\nexport type GqlExcludeInput = {\n  /** Messages to exclude from the selection. */\n  messages: Array<Scalars['MessageId']>;\n  /** Utxos to exclude from the selection. */\n  utxos: Array<Scalars['UtxoId']>;\n};\n\nexport type GqlFailureStatus = {\n  __typename: 'FailureStatus';\n  block: GqlBlock;\n  programState?: Maybe<GqlProgramState>;\n  reason: Scalars['String'];\n  time: Scalars['Tai64Timestamp'];\n};\n\nexport type GqlGenesis = {\n  __typename: 'Genesis';\n  /**\n   * The chain configs define what consensus type to use, what settlement layer to use,\n   * rules of block validity, etc.\n   */\n  chainConfigHash: Scalars['Bytes32'];\n  /** The Binary Merkle Tree root of all genesis coins. */\n  coinsRoot: Scalars['Bytes32'];\n  /** The Binary Merkle Tree root of state, balances, contracts code hash of each contract. */\n  contractsRoot: Scalars['Bytes32'];\n  /** The Binary Merkle Tree root of all genesis messages. */\n  messagesRoot: Scalars['Bytes32'];\n};\n\nexport type GqlHeader = {\n  __typename: 'Header';\n  /** Hash of the application header. */\n  applicationHash: Scalars['Bytes32'];\n  /** The layer 1 height of messages and events to include since the last layer 1 block number. */\n  daHeight: Scalars['U64'];\n  /** Fuel block height. */\n  height: Scalars['U64'];\n  /** Hash of the header */\n  id: Scalars['BlockId'];\n  /** Number of output messages in this block. */\n  outputMessagesCount: Scalars['U64'];\n  /** Merkle root of messages in this block. */\n  outputMessagesRoot: Scalars['Bytes32'];\n  /** Merkle root of all previous block header hashes. */\n  prevRoot: Scalars['Bytes32'];\n  /** The block producer time. */\n  time: Scalars['Tai64Timestamp'];\n  /** Number of transactions in this block. */\n  transactionsCount: Scalars['U64'];\n  /** Merkle root of transactions. */\n  transactionsRoot: Scalars['Bytes32'];\n};\n\nexport type GqlInput = GqlInputCoin | GqlInputContract | GqlInputMessage;\n\nexport type GqlInputCoin = {\n  __typename: 'InputCoin';\n  amount: Scalars['U64'];\n  assetId: Scalars['AssetId'];\n  maturity: Scalars['U64'];\n  owner: Scalars['Address'];\n  predicate: Scalars['HexString'];\n  predicateData: Scalars['HexString'];\n  txPointer: Scalars['TxPointer'];\n  utxoId: Scalars['UtxoId'];\n  witnessIndex: Scalars['Int'];\n};\n\nexport type GqlInputContract = {\n  __typename: 'InputContract';\n  balanceRoot: Scalars['Bytes32'];\n  contract: GqlContract;\n  stateRoot: Scalars['Bytes32'];\n  txPointer: Scalars['TxPointer'];\n  utxoId: Scalars['UtxoId'];\n};\n\nexport type GqlInputMessage = {\n  __typename: 'InputMessage';\n  amount: Scalars['U64'];\n  data: Scalars['HexString'];\n  messageId: Scalars['MessageId'];\n  nonce: Scalars['U64'];\n  predicate: Scalars['HexString'];\n  predicateData: Scalars['HexString'];\n  recipient: Scalars['Address'];\n  sender: Scalars['Address'];\n  witnessIndex: Scalars['Int'];\n};\n\nexport type GqlMessage = {\n  __typename: 'Message';\n  amount: Scalars['U64'];\n  daHeight: Scalars['U64'];\n  data: Scalars['HexString'];\n  messageId: Scalars['MessageId'];\n  nonce: Scalars['U64'];\n  recipient: Scalars['Address'];\n  sender: Scalars['Address'];\n  status: GqlMessageStatus;\n};\n\nexport type GqlMessageConnection = {\n  __typename: 'MessageConnection';\n  /** A list of edges. */\n  edges: Array<GqlMessageEdge>;\n  /** A list of nodes. */\n  nodes: Array<GqlMessage>;\n  /** Information to aid in pagination. */\n  pageInfo: GqlPageInfo;\n};\n\n/** An edge in a connection. */\nexport type GqlMessageEdge = {\n  __typename: 'MessageEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge */\n  node: GqlMessage;\n};\n\nexport type GqlMessageOutput = {\n  __typename: 'MessageOutput';\n  amount: Scalars['U64'];\n  recipient: Scalars['Address'];\n};\n\nexport type GqlMessageProof = {\n  __typename: 'MessageProof';\n  amount: Scalars['U64'];\n  data: Scalars['HexString'];\n  header: GqlHeader;\n  nonce: Scalars['Bytes32'];\n  proofIndex: Scalars['U64'];\n  proofSet: Array<Scalars['Bytes32']>;\n  recipient: Scalars['Address'];\n  sender: Scalars['Address'];\n  signature: Scalars['Signature'];\n};\n\nexport enum GqlMessageStatus {\n  Spent = 'SPENT',\n  Unspent = 'UNSPENT',\n}\n\nexport type GqlMutation = {\n  __typename: 'Mutation';\n  continueTx: GqlRunResult;\n  /** Execute a dry-run of the transaction using a fork of current state, no changes are committed. */\n  dryRun: Array<GqlReceipt>;\n  endSession: Scalars['Boolean'];\n  execute: Scalars['Boolean'];\n  produceBlocks: Scalars['U64'];\n  reset: Scalars['Boolean'];\n  setBreakpoint: Scalars['Boolean'];\n  setSingleStepping: Scalars['Boolean'];\n  startSession: Scalars['ID'];\n  startTx: GqlRunResult;\n  /** Submits transaction to the txpool */\n  submit: GqlTransaction;\n};\n\nexport type GqlMutationContinueTxArgs = {\n  id: Scalars['ID'];\n};\n\nexport type GqlMutationDryRunArgs = {\n  tx: Scalars['HexString'];\n  utxoValidation?: InputMaybe<Scalars['Boolean']>;\n};\n\nexport type GqlMutationEndSessionArgs = {\n  id: Scalars['ID'];\n};\n\nexport type GqlMutationExecuteArgs = {\n  id: Scalars['ID'];\n  op: Scalars['String'];\n};\n\nexport type GqlMutationProduceBlocksArgs = {\n  blocksToProduce: Scalars['U64'];\n  time?: InputMaybe<GqlTimeParameters>;\n};\n\nexport type GqlMutationResetArgs = {\n  id: Scalars['ID'];\n};\n\nexport type GqlMutationSetBreakpointArgs = {\n  breakpoint: GqlBreakpoint;\n  id: Scalars['ID'];\n};\n\nexport type GqlMutationSetSingleSteppingArgs = {\n  enable: Scalars['Boolean'];\n  id: Scalars['ID'];\n};\n\nexport type GqlMutationStartTxArgs = {\n  id: Scalars['ID'];\n  txJson: Scalars['String'];\n};\n\nexport type GqlMutationSubmitArgs = {\n  tx: Scalars['HexString'];\n};\n\nexport type GqlNodeInfo = {\n  __typename: 'NodeInfo';\n  maxDepth: Scalars['U64'];\n  maxTx: Scalars['U64'];\n  minGasPrice: Scalars['U64'];\n  nodeVersion: Scalars['String'];\n  utxoValidation: Scalars['Boolean'];\n  vmBacktrace: Scalars['Boolean'];\n};\n\nexport type GqlOutput =\n  | GqlChangeOutput\n  | GqlCoinOutput\n  | GqlContractCreated\n  | GqlContractOutput\n  | GqlMessageOutput\n  | GqlVariableOutput;\n\n/**\n * A separate `Breakpoint` type to be used as an output, as a single\n * type cannot act as both input and output type in async-graphql\n */\nexport type GqlOutputBreakpoint = {\n  __typename: 'OutputBreakpoint';\n  contract: Scalars['ContractId'];\n  pc: Scalars['U64'];\n};\n\n/** Information about pagination in a connection */\nexport type GqlPageInfo = {\n  __typename: 'PageInfo';\n  /** When paginating forwards, the cursor to continue. */\n  endCursor?: Maybe<Scalars['String']>;\n  /** When paginating forwards, are there more items? */\n  hasNextPage: Scalars['Boolean'];\n  /** When paginating backwards, are there more items? */\n  hasPreviousPage: Scalars['Boolean'];\n  /** When paginating backwards, the cursor to continue. */\n  startCursor?: Maybe<Scalars['String']>;\n};\n\nexport type GqlPoAConsensus = {\n  __typename: 'PoAConsensus';\n  /** Gets the signature of the block produced by `PoA` consensus. */\n  signature: Scalars['Signature'];\n};\n\nexport type GqlProgramState = {\n  __typename: 'ProgramState';\n  data: Scalars['HexString'];\n  returnType: GqlReturnType;\n};\n\nexport type GqlQuery = {\n  __typename: 'Query';\n  balance: GqlBalance;\n  balances: GqlBalanceConnection;\n  block?: Maybe<GqlBlock>;\n  blocks: GqlBlockConnection;\n  chain: GqlChainInfo;\n  /** Gets the coin by `utxo_id`. */\n  coin?: Maybe<GqlCoin>;\n  /**\n   * Gets all coins of some `owner` maybe filtered with by `asset_id` per page.\n   * It includes `CoinStatus::Spent` and `CoinStatus::Unspent` coins.\n   */\n  coins: GqlCoinConnection;\n  contract?: Maybe<GqlContract>;\n  contractBalance: GqlContractBalance;\n  contractBalances: GqlContractBalanceConnection;\n  /** Returns true when the GraphQL API is serving requests. */\n  health: Scalars['Boolean'];\n  memory: Scalars['String'];\n  messageProof?: Maybe<GqlMessageProof>;\n  messages: GqlMessageConnection;\n  nodeInfo: GqlNodeInfo;\n  register: Scalars['U64'];\n  /**\n   * For each `query_per_asset`, get some spendable resources(of asset specified by the query) owned by\n   * `owner` that add up at least the query amount. The returned resources are actual resources\n   * that can be spent. The number of resources is optimized to prevent dust accumulation.\n   * Max number of resources and excluded resources can also be specified.\n   *\n   * Returns:\n   * The list of spendable resources per asset from the query. The length of the result is\n   * the same as the length of `query_per_asset`. The ordering of assets and `query_per_asset`\n   * is the same.\n   */\n  resourcesToSpend: Array<Array<GqlResource>>;\n  transaction?: Maybe<GqlTransaction>;\n  transactions: GqlTransactionConnection;\n  transactionsByOwner: GqlTransactionConnection;\n};\n\nexport type GqlQueryBalanceArgs = {\n  assetId: Scalars['AssetId'];\n  owner: Scalars['Address'];\n};\n\nexport type GqlQueryBalancesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  filter: GqlBalanceFilterInput;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\nexport type GqlQueryBlockArgs = {\n  height?: InputMaybe<Scalars['U64']>;\n  id?: InputMaybe<Scalars['BlockId']>;\n};\n\nexport type GqlQueryBlocksArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\nexport type GqlQueryCoinArgs = {\n  utxoId: Scalars['UtxoId'];\n};\n\nexport type GqlQueryCoinsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  filter: GqlCoinFilterInput;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\nexport type GqlQueryContractArgs = {\n  id: Scalars['ContractId'];\n};\n\nexport type GqlQueryContractBalanceArgs = {\n  asset: Scalars['AssetId'];\n  contract: Scalars['ContractId'];\n};\n\nexport type GqlQueryContractBalancesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  filter: GqlContractBalanceFilterInput;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\nexport type GqlQueryMemoryArgs = {\n  id: Scalars['ID'];\n  size: Scalars['U64'];\n  start: Scalars['U64'];\n};\n\nexport type GqlQueryMessageProofArgs = {\n  messageId: Scalars['MessageId'];\n  transactionId: Scalars['TransactionId'];\n};\n\nexport type GqlQueryMessagesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  owner?: InputMaybe<Scalars['Address']>;\n};\n\nexport type GqlQueryRegisterArgs = {\n  id: Scalars['ID'];\n  register: Scalars['U64'];\n};\n\nexport type GqlQueryResourcesToSpendArgs = {\n  excludedIds?: InputMaybe<GqlExcludeInput>;\n  owner: Scalars['Address'];\n  queryPerAsset: Array<GqlSpendQueryElementInput>;\n};\n\nexport type GqlQueryTransactionArgs = {\n  id: Scalars['TransactionId'];\n};\n\nexport type GqlQueryTransactionsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\nexport type GqlQueryTransactionsByOwnerArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  owner: Scalars['Address'];\n};\n\nexport type GqlReceipt = {\n  __typename: 'Receipt';\n  amount?: Maybe<Scalars['U64']>;\n  assetId?: Maybe<Scalars['AssetId']>;\n  contract?: Maybe<GqlContract>;\n  contractId?: Maybe<Scalars['ContractId']>;\n  data?: Maybe<Scalars['HexString']>;\n  digest?: Maybe<Scalars['Bytes32']>;\n  gas?: Maybe<Scalars['U64']>;\n  gasUsed?: Maybe<Scalars['U64']>;\n  is?: Maybe<Scalars['U64']>;\n  len?: Maybe<Scalars['U64']>;\n  messageId?: Maybe<Scalars['MessageId']>;\n  nonce?: Maybe<Scalars['Bytes32']>;\n  param1?: Maybe<Scalars['U64']>;\n  param2?: Maybe<Scalars['U64']>;\n  pc?: Maybe<Scalars['U64']>;\n  ptr?: Maybe<Scalars['U64']>;\n  ra?: Maybe<Scalars['U64']>;\n  rawPayload: Scalars['HexString'];\n  rb?: Maybe<Scalars['U64']>;\n  rc?: Maybe<Scalars['U64']>;\n  rd?: Maybe<Scalars['U64']>;\n  reason?: Maybe<Scalars['U64']>;\n  receiptType: GqlReceiptType;\n  recipient?: Maybe<Scalars['Address']>;\n  result?: Maybe<Scalars['U64']>;\n  sender?: Maybe<Scalars['Address']>;\n  to?: Maybe<GqlContract>;\n  toAddress?: Maybe<Scalars['Address']>;\n  val?: Maybe<Scalars['U64']>;\n};\n\nexport enum GqlReceiptType {\n  Call = 'CALL',\n  Log = 'LOG',\n  LogData = 'LOG_DATA',\n  MessageOut = 'MESSAGE_OUT',\n  Panic = 'PANIC',\n  Return = 'RETURN',\n  ReturnData = 'RETURN_DATA',\n  Revert = 'REVERT',\n  ScriptResult = 'SCRIPT_RESULT',\n  Transfer = 'TRANSFER',\n  TransferOut = 'TRANSFER_OUT',\n}\n\n/** The schema analog of the [`resource::Resource`]. */\nexport type GqlResource = GqlCoin | GqlMessage;\n\nexport enum GqlReturnType {\n  Return = 'RETURN',\n  ReturnData = 'RETURN_DATA',\n  Revert = 'REVERT',\n}\n\nexport type GqlRunResult = {\n  __typename: 'RunResult';\n  breakpoint?: Maybe<GqlOutputBreakpoint>;\n  jsonReceipts: Array<Scalars['String']>;\n  state: GqlRunState;\n};\n\nexport enum GqlRunState {\n  /** Stopped on a breakpoint */\n  Breakpoint = 'BREAKPOINT',\n  /** All breakpoints have been processed, and the program has terminated */\n  Completed = 'COMPLETED',\n}\n\nexport type GqlSpendQueryElementInput = {\n  /** Target amount for the query. */\n  amount: Scalars['U64'];\n  /** Identifier of the asset to spend. */\n  assetId: Scalars['AssetId'];\n  /** The maximum number of currencies for selection. */\n  max?: InputMaybe<Scalars['U64']>;\n};\n\nexport type GqlSqueezedOutStatus = {\n  __typename: 'SqueezedOutStatus';\n  reason: Scalars['String'];\n};\n\nexport type GqlSubmittedStatus = {\n  __typename: 'SubmittedStatus';\n  time: Scalars['Tai64Timestamp'];\n};\n\nexport type GqlSubscription = {\n  __typename: 'Subscription';\n  /**\n   * Returns a stream of status updates for the given transaction id.\n   * If the current status is [`TransactionStatus::Success`], [`TransactionStatus::SqueezedOut`]\n   * or [`TransactionStatus::Failed`] the stream will return that and end immediately.\n   * If the current status is [`TransactionStatus::Submitted`] this will be returned\n   * and the stream will wait for a future update.\n   *\n   * This stream will wait forever so it's advised to use within a timeout.\n   *\n   * It is possible for the stream to miss an update if it is polled slower\n   * than the updates arrive. In such a case, the stream will close without\n   * a status. If this occurs the stream can simply be restarted to return\n   * the latest status.\n   */\n  statusChange: GqlTransactionStatus;\n};\n\nexport type GqlSubscriptionStatusChangeArgs = {\n  id: Scalars['TransactionId'];\n};\n\nexport type GqlSuccessStatus = {\n  __typename: 'SuccessStatus';\n  block: GqlBlock;\n  programState?: Maybe<GqlProgramState>;\n  time: Scalars['Tai64Timestamp'];\n};\n\nexport type GqlTimeParameters = {\n  /** The time interval between subsequent blocks */\n  blockTimeInterval: Scalars['U64'];\n  /** The time to set on the first block */\n  startTime: Scalars['U64'];\n};\n\nexport type GqlTransaction = {\n  __typename: 'Transaction';\n  bytecodeLength?: Maybe<Scalars['U64']>;\n  bytecodeWitnessIndex?: Maybe<Scalars['Int']>;\n  gasLimit?: Maybe<Scalars['U64']>;\n  gasPrice?: Maybe<Scalars['U64']>;\n  id: Scalars['TransactionId'];\n  inputAssetIds?: Maybe<Array<Scalars['AssetId']>>;\n  inputContracts?: Maybe<Array<GqlContract>>;\n  inputs?: Maybe<Array<GqlInput>>;\n  isCreate: Scalars['Boolean'];\n  isMint: Scalars['Boolean'];\n  isScript: Scalars['Boolean'];\n  maturity?: Maybe<Scalars['U64']>;\n  outputs: Array<GqlOutput>;\n  /** Return the transaction bytes using canonical encoding */\n  rawPayload: Scalars['HexString'];\n  receipts?: Maybe<Array<GqlReceipt>>;\n  receiptsRoot?: Maybe<Scalars['Bytes32']>;\n  salt?: Maybe<Scalars['Salt']>;\n  script?: Maybe<Scalars['HexString']>;\n  scriptData?: Maybe<Scalars['HexString']>;\n  status?: Maybe<GqlTransactionStatus>;\n  storageSlots?: Maybe<Array<Scalars['HexString']>>;\n  txPointer?: Maybe<Scalars['TxPointer']>;\n  witnesses?: Maybe<Array<Scalars['HexString']>>;\n};\n\nexport type GqlTransactionConnection = {\n  __typename: 'TransactionConnection';\n  /** A list of edges. */\n  edges: Array<GqlTransactionEdge>;\n  /** A list of nodes. */\n  nodes: Array<GqlTransaction>;\n  /** Information to aid in pagination. */\n  pageInfo: GqlPageInfo;\n};\n\n/** An edge in a connection. */\nexport type GqlTransactionEdge = {\n  __typename: 'TransactionEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge */\n  node: GqlTransaction;\n};\n\nexport type GqlTransactionStatus =\n  | GqlFailureStatus\n  | GqlSqueezedOutStatus\n  | GqlSubmittedStatus\n  | GqlSuccessStatus;\n\nexport type GqlVariableOutput = {\n  __typename: 'VariableOutput';\n  amount: Scalars['U64'];\n  assetId: Scalars['AssetId'];\n  to: Scalars['Address'];\n};\n\nexport type GqlTransactionFragmentFragment = {\n  __typename: 'Transaction';\n  id: string;\n  rawPayload: string;\n  gasPrice?: string | null;\n  status?:\n    | {\n        __typename: 'FailureStatus';\n        time: any;\n        reason: string;\n        type: 'FailureStatus';\n        block: { __typename: 'Block'; id: string };\n      }\n    | { __typename: 'SqueezedOutStatus'; type: 'SqueezedOutStatus' }\n    | { __typename: 'SubmittedStatus'; time: any; type: 'SubmittedStatus' }\n    | {\n        __typename: 'SuccessStatus';\n        time: any;\n        type: 'SuccessStatus';\n        block: { __typename: 'Block'; id: string };\n        programState?: {\n          __typename: 'ProgramState';\n          returnType: GqlReturnType;\n          data: string;\n        } | null;\n      }\n    | null;\n};\n\nexport type GqlReceiptFragmentFragment = {\n  __typename: 'Receipt';\n  data?: string | null;\n  rawPayload: string;\n};\n\nexport type GqlBlockFragmentFragment = {\n  __typename: 'Block';\n  id: string;\n  header: { __typename: 'Header'; height: string; time: any };\n  transactions: Array<{ __typename: 'Transaction'; id: string }>;\n};\n\nexport type GqlCoinFragmentFragment = {\n  __typename: 'Coin';\n  utxoId: string;\n  owner: string;\n  amount: string;\n  assetId: string;\n  maturity: string;\n  blockCreated: string;\n  coinStatus: GqlCoinStatus;\n};\n\nexport type GqlMessageFragmentFragment = {\n  __typename: 'Message';\n  amount: string;\n  sender: string;\n  recipient: string;\n  data: string;\n  nonce: string;\n  daHeight: string;\n  messageStatus: GqlMessageStatus;\n};\n\nexport type GqlMessageProofFragmentFragment = {\n  __typename: 'MessageProof';\n  proofSet: Array<string>;\n  proofIndex: string;\n  sender: string;\n  recipient: string;\n  nonce: string;\n  amount: string;\n  data: string;\n  signature: any;\n  header: {\n    __typename: 'Header';\n    id: string;\n    daHeight: string;\n    transactionsCount: string;\n    outputMessagesCount: string;\n    transactionsRoot: string;\n    outputMessagesRoot: string;\n    height: string;\n    prevRoot: string;\n    time: any;\n    applicationHash: string;\n  };\n};\n\nexport type GqlBalanceFragmentFragment = {\n  __typename: 'Balance';\n  owner: string;\n  amount: string;\n  assetId: string;\n};\n\nexport type GqlConsensusParametersFragmentFragment = {\n  __typename: 'ConsensusParameters';\n  contractMaxSize: string;\n  maxInputs: string;\n  maxOutputs: string;\n  maxWitnesses: string;\n  maxGasPerTx: string;\n  maxScriptLength: string;\n  maxScriptDataLength: string;\n  maxStorageSlots: string;\n  maxPredicateLength: string;\n  maxPredicateDataLength: string;\n  gasPriceFactor: string;\n  gasPerByte: string;\n  maxMessageDataLength: string;\n};\n\nexport type GqlChainInfoFragmentFragment = {\n  __typename: 'ChainInfo';\n  name: string;\n  baseChainHeight: string;\n  peerCount: number;\n  consensusParameters: {\n    __typename: 'ConsensusParameters';\n    contractMaxSize: string;\n    maxInputs: string;\n    maxOutputs: string;\n    maxWitnesses: string;\n    maxGasPerTx: string;\n    maxScriptLength: string;\n    maxScriptDataLength: string;\n    maxStorageSlots: string;\n    maxPredicateLength: string;\n    maxPredicateDataLength: string;\n    gasPriceFactor: string;\n    gasPerByte: string;\n    maxMessageDataLength: string;\n  };\n  latestBlock: {\n    __typename: 'Block';\n    id: string;\n    header: { __typename: 'Header'; height: string; time: any };\n    transactions: Array<{ __typename: 'Transaction'; id: string }>;\n  };\n};\n\nexport type GqlContractBalanceFragmentFragment = {\n  __typename: 'ContractBalance';\n  contract: string;\n  amount: string;\n  assetId: string;\n};\n\nexport type GqlGetVersionQueryVariables = Exact<{ [key: string]: never }>;\n\nexport type GqlGetVersionQuery = {\n  __typename: 'Query';\n  nodeInfo: { __typename: 'NodeInfo'; nodeVersion: string };\n};\n\nexport type GqlGetInfoQueryVariables = Exact<{ [key: string]: never }>;\n\nexport type GqlGetInfoQuery = {\n  __typename: 'Query';\n  nodeInfo: { __typename: 'NodeInfo'; nodeVersion: string; minGasPrice: string };\n};\n\nexport type GqlGetChainQueryVariables = Exact<{ [key: string]: never }>;\n\nexport type GqlGetChainQuery = {\n  __typename: 'Query';\n  chain: {\n    __typename: 'ChainInfo';\n    name: string;\n    baseChainHeight: string;\n    peerCount: number;\n    consensusParameters: {\n      __typename: 'ConsensusParameters';\n      contractMaxSize: string;\n      maxInputs: string;\n      maxOutputs: string;\n      maxWitnesses: string;\n      maxGasPerTx: string;\n      maxScriptLength: string;\n      maxScriptDataLength: string;\n      maxStorageSlots: string;\n      maxPredicateLength: string;\n      maxPredicateDataLength: string;\n      gasPriceFactor: string;\n      gasPerByte: string;\n      maxMessageDataLength: string;\n    };\n    latestBlock: {\n      __typename: 'Block';\n      id: string;\n      header: { __typename: 'Header'; height: string; time: any };\n      transactions: Array<{ __typename: 'Transaction'; id: string }>;\n    };\n  };\n};\n\nexport type GqlGetTransactionQueryVariables = Exact<{\n  transactionId: Scalars['TransactionId'];\n}>;\n\nexport type GqlGetTransactionQuery = {\n  __typename: 'Query';\n  transaction?: {\n    __typename: 'Transaction';\n    id: string;\n    rawPayload: string;\n    gasPrice?: string | null;\n    status?:\n      | {\n          __typename: 'FailureStatus';\n          time: any;\n          reason: string;\n          type: 'FailureStatus';\n          block: { __typename: 'Block'; id: string };\n        }\n      | { __typename: 'SqueezedOutStatus'; type: 'SqueezedOutStatus' }\n      | { __typename: 'SubmittedStatus'; time: any; type: 'SubmittedStatus' }\n      | {\n          __typename: 'SuccessStatus';\n          time: any;\n          type: 'SuccessStatus';\n          block: { __typename: 'Block'; id: string };\n          programState?: {\n            __typename: 'ProgramState';\n            returnType: GqlReturnType;\n            data: string;\n          } | null;\n        }\n      | null;\n  } | null;\n};\n\nexport type GqlGetTransactionWithReceiptsQueryVariables = Exact<{\n  transactionId: Scalars['TransactionId'];\n}>;\n\nexport type GqlGetTransactionWithReceiptsQuery = {\n  __typename: 'Query';\n  transaction?: {\n    __typename: 'Transaction';\n    id: string;\n    rawPayload: string;\n    gasPrice?: string | null;\n    receipts?: Array<{ __typename: 'Receipt'; data?: string | null; rawPayload: string }> | null;\n    status?:\n      | {\n          __typename: 'FailureStatus';\n          time: any;\n          reason: string;\n          type: 'FailureStatus';\n          block: { __typename: 'Block'; id: string };\n        }\n      | { __typename: 'SqueezedOutStatus'; type: 'SqueezedOutStatus' }\n      | { __typename: 'SubmittedStatus'; time: any; type: 'SubmittedStatus' }\n      | {\n          __typename: 'SuccessStatus';\n          time: any;\n          type: 'SuccessStatus';\n          block: { __typename: 'Block'; id: string };\n          programState?: {\n            __typename: 'ProgramState';\n            returnType: GqlReturnType;\n            data: string;\n          } | null;\n        }\n      | null;\n  } | null;\n};\n\nexport type GqlGetTransactionsQueryVariables = Exact<{\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n}>;\n\nexport type GqlGetTransactionsQuery = {\n  __typename: 'Query';\n  transactions: {\n    __typename: 'TransactionConnection';\n    edges: Array<{\n      __typename: 'TransactionEdge';\n      node: {\n        __typename: 'Transaction';\n        id: string;\n        rawPayload: string;\n        gasPrice?: string | null;\n        status?:\n          | {\n              __typename: 'FailureStatus';\n              time: any;\n              reason: string;\n              type: 'FailureStatus';\n              block: { __typename: 'Block'; id: string };\n            }\n          | { __typename: 'SqueezedOutStatus'; type: 'SqueezedOutStatus' }\n          | { __typename: 'SubmittedStatus'; time: any; type: 'SubmittedStatus' }\n          | {\n              __typename: 'SuccessStatus';\n              time: any;\n              type: 'SuccessStatus';\n              block: { __typename: 'Block'; id: string };\n              programState?: {\n                __typename: 'ProgramState';\n                returnType: GqlReturnType;\n                data: string;\n              } | null;\n            }\n          | null;\n      };\n    }>;\n  };\n};\n\nexport type GqlGetTransactionsByOwnerQueryVariables = Exact<{\n  owner: Scalars['Address'];\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n}>;\n\nexport type GqlGetTransactionsByOwnerQuery = {\n  __typename: 'Query';\n  transactionsByOwner: {\n    __typename: 'TransactionConnection';\n    edges: Array<{\n      __typename: 'TransactionEdge';\n      node: {\n        __typename: 'Transaction';\n        id: string;\n        rawPayload: string;\n        gasPrice?: string | null;\n        status?:\n          | {\n              __typename: 'FailureStatus';\n              time: any;\n              reason: string;\n              type: 'FailureStatus';\n              block: { __typename: 'Block'; id: string };\n            }\n          | { __typename: 'SqueezedOutStatus'; type: 'SqueezedOutStatus' }\n          | { __typename: 'SubmittedStatus'; time: any; type: 'SubmittedStatus' }\n          | {\n              __typename: 'SuccessStatus';\n              time: any;\n              type: 'SuccessStatus';\n              block: { __typename: 'Block'; id: string };\n              programState?: {\n                __typename: 'ProgramState';\n                returnType: GqlReturnType;\n                data: string;\n              } | null;\n            }\n          | null;\n      };\n    }>;\n  };\n};\n\nexport type GqlGetBlockQueryVariables = Exact<{\n  blockId?: InputMaybe<Scalars['BlockId']>;\n  blockHeight?: InputMaybe<Scalars['U64']>;\n}>;\n\nexport type GqlGetBlockQuery = {\n  __typename: 'Query';\n  block?: {\n    __typename: 'Block';\n    id: string;\n    header: { __typename: 'Header'; height: string; time: any };\n    transactions: Array<{ __typename: 'Transaction'; id: string }>;\n  } | null;\n};\n\nexport type GqlGetBlockWithTransactionsQueryVariables = Exact<{\n  blockId?: InputMaybe<Scalars['BlockId']>;\n  blockHeight?: InputMaybe<Scalars['U64']>;\n}>;\n\nexport type GqlGetBlockWithTransactionsQuery = {\n  __typename: 'Query';\n  block?: {\n    __typename: 'Block';\n    id: string;\n    transactions: Array<{\n      __typename: 'Transaction';\n      id: string;\n      rawPayload: string;\n      gasPrice?: string | null;\n      status?:\n        | {\n            __typename: 'FailureStatus';\n            time: any;\n            reason: string;\n            type: 'FailureStatus';\n            block: { __typename: 'Block'; id: string };\n          }\n        | { __typename: 'SqueezedOutStatus'; type: 'SqueezedOutStatus' }\n        | { __typename: 'SubmittedStatus'; time: any; type: 'SubmittedStatus' }\n        | {\n            __typename: 'SuccessStatus';\n            time: any;\n            type: 'SuccessStatus';\n            block: { __typename: 'Block'; id: string };\n            programState?: {\n              __typename: 'ProgramState';\n              returnType: GqlReturnType;\n              data: string;\n            } | null;\n          }\n        | null;\n    }>;\n    header: { __typename: 'Header'; height: string; time: any };\n  } | null;\n};\n\nexport type GqlGetBlocksQueryVariables = Exact<{\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n}>;\n\nexport type GqlGetBlocksQuery = {\n  __typename: 'Query';\n  blocks: {\n    __typename: 'BlockConnection';\n    edges: Array<{\n      __typename: 'BlockEdge';\n      node: {\n        __typename: 'Block';\n        id: string;\n        header: { __typename: 'Header'; height: string; time: any };\n        transactions: Array<{ __typename: 'Transaction'; id: string }>;\n      };\n    }>;\n  };\n};\n\nexport type GqlGetCoinQueryVariables = Exact<{\n  coinId: Scalars['UtxoId'];\n}>;\n\nexport type GqlGetCoinQuery = {\n  __typename: 'Query';\n  coin?: {\n    __typename: 'Coin';\n    utxoId: string;\n    owner: string;\n    amount: string;\n    assetId: string;\n    maturity: string;\n    blockCreated: string;\n    coinStatus: GqlCoinStatus;\n  } | null;\n};\n\nexport type GqlGetCoinsQueryVariables = Exact<{\n  filter: GqlCoinFilterInput;\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n}>;\n\nexport type GqlGetCoinsQuery = {\n  __typename: 'Query';\n  coins: {\n    __typename: 'CoinConnection';\n    edges: Array<{\n      __typename: 'CoinEdge';\n      node: {\n        __typename: 'Coin';\n        utxoId: string;\n        owner: string;\n        amount: string;\n        assetId: string;\n        maturity: string;\n        blockCreated: string;\n        coinStatus: GqlCoinStatus;\n      };\n    }>;\n  };\n};\n\nexport type GqlGetResourcesToSpendQueryVariables = Exact<{\n  owner: Scalars['Address'];\n  queryPerAsset: Array<GqlSpendQueryElementInput> | GqlSpendQueryElementInput;\n  excludedIds?: InputMaybe<GqlExcludeInput>;\n}>;\n\nexport type GqlGetResourcesToSpendQuery = {\n  __typename: 'Query';\n  resourcesToSpend: Array<\n    Array<\n      | {\n          __typename: 'Coin';\n          utxoId: string;\n          owner: string;\n          amount: string;\n          assetId: string;\n          maturity: string;\n          blockCreated: string;\n          coinStatus: GqlCoinStatus;\n        }\n      | {\n          __typename: 'Message';\n          amount: string;\n          sender: string;\n          recipient: string;\n          data: string;\n          nonce: string;\n          daHeight: string;\n          messageStatus: GqlMessageStatus;\n        }\n    >\n  >;\n};\n\nexport type GqlGetContractQueryVariables = Exact<{\n  contractId: Scalars['ContractId'];\n}>;\n\nexport type GqlGetContractQuery = {\n  __typename: 'Query';\n  contract?: { __typename: 'Contract'; bytecode: string; id: string } | null;\n};\n\nexport type GqlGetContractBalanceQueryVariables = Exact<{\n  contract: Scalars['ContractId'];\n  asset: Scalars['AssetId'];\n}>;\n\nexport type GqlGetContractBalanceQuery = {\n  __typename: 'Query';\n  contractBalance: {\n    __typename: 'ContractBalance';\n    contract: string;\n    amount: string;\n    assetId: string;\n  };\n};\n\nexport type GqlGetBalanceQueryVariables = Exact<{\n  owner: Scalars['Address'];\n  assetId: Scalars['AssetId'];\n}>;\n\nexport type GqlGetBalanceQuery = {\n  __typename: 'Query';\n  balance: { __typename: 'Balance'; owner: string; amount: string; assetId: string };\n};\n\nexport type GqlGetBalancesQueryVariables = Exact<{\n  filter: GqlBalanceFilterInput;\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n}>;\n\nexport type GqlGetBalancesQuery = {\n  __typename: 'Query';\n  balances: {\n    __typename: 'BalanceConnection';\n    edges: Array<{\n      __typename: 'BalanceEdge';\n      node: { __typename: 'Balance'; owner: string; amount: string; assetId: string };\n    }>;\n  };\n};\n\nexport type GqlGetMessagesQueryVariables = Exact<{\n  owner: Scalars['Address'];\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n}>;\n\nexport type GqlGetMessagesQuery = {\n  __typename: 'Query';\n  messages: {\n    __typename: 'MessageConnection';\n    edges: Array<{\n      __typename: 'MessageEdge';\n      node: {\n        __typename: 'Message';\n        amount: string;\n        sender: string;\n        recipient: string;\n        data: string;\n        nonce: string;\n        daHeight: string;\n        messageStatus: GqlMessageStatus;\n      };\n    }>;\n  };\n};\n\nexport type GqlGetMessageProofQueryVariables = Exact<{\n  transactionId: Scalars['TransactionId'];\n  messageId: Scalars['MessageId'];\n}>;\n\nexport type GqlGetMessageProofQuery = {\n  __typename: 'Query';\n  messageProof?: {\n    __typename: 'MessageProof';\n    proofSet: Array<string>;\n    proofIndex: string;\n    sender: string;\n    recipient: string;\n    nonce: string;\n    amount: string;\n    data: string;\n    signature: any;\n    header: {\n      __typename: 'Header';\n      id: string;\n      daHeight: string;\n      transactionsCount: string;\n      outputMessagesCount: string;\n      transactionsRoot: string;\n      outputMessagesRoot: string;\n      height: string;\n      prevRoot: string;\n      time: any;\n      applicationHash: string;\n    };\n  } | null;\n};\n\nexport type GqlDryRunMutationVariables = Exact<{\n  encodedTransaction: Scalars['HexString'];\n  utxoValidation?: InputMaybe<Scalars['Boolean']>;\n}>;\n\nexport type GqlDryRunMutation = {\n  __typename: 'Mutation';\n  dryRun: Array<{ __typename: 'Receipt'; data?: string | null; rawPayload: string }>;\n};\n\nexport type GqlSubmitMutationVariables = Exact<{\n  encodedTransaction: Scalars['HexString'];\n}>;\n\nexport type GqlSubmitMutation = {\n  __typename: 'Mutation';\n  submit: { __typename: 'Transaction'; id: string };\n};\n\nexport type GqlStartSessionMutationVariables = Exact<{ [key: string]: never }>;\n\nexport type GqlStartSessionMutation = { __typename: 'Mutation'; startSession: string };\n\nexport type GqlEndSessionMutationVariables = Exact<{\n  sessionId: Scalars['ID'];\n}>;\n\nexport type GqlEndSessionMutation = { __typename: 'Mutation'; endSession: boolean };\n\nexport type GqlExecuteMutationVariables = Exact<{\n  sessionId: Scalars['ID'];\n  op: Scalars['String'];\n}>;\n\nexport type GqlExecuteMutation = { __typename: 'Mutation'; execute: boolean };\n\nexport type GqlResetMutationVariables = Exact<{\n  sessionId: Scalars['ID'];\n}>;\n\nexport type GqlResetMutation = { __typename: 'Mutation'; reset: boolean };\n\nexport const TransactionFragmentFragmentDoc = gql`\n  fragment transactionFragment on Transaction {\n    id\n    rawPayload\n    gasPrice\n    status {\n      type: __typename\n      ... on SubmittedStatus {\n        time\n      }\n      ... on SuccessStatus {\n        block {\n          id\n        }\n        time\n        programState {\n          returnType\n          data\n        }\n      }\n      ... on FailureStatus {\n        block {\n          id\n        }\n        time\n        reason\n      }\n    }\n  }\n`;\nexport const ReceiptFragmentFragmentDoc = gql`\n  fragment receiptFragment on Receipt {\n    data\n    rawPayload\n  }\n`;\nexport const CoinFragmentFragmentDoc = gql`\n  fragment coinFragment on Coin {\n    utxoId\n    owner\n    amount\n    assetId\n    maturity\n    coinStatus: status\n    blockCreated\n  }\n`;\nexport const MessageFragmentFragmentDoc = gql`\n  fragment messageFragment on Message {\n    amount\n    sender\n    recipient\n    data\n    nonce\n    messageStatus: status\n    daHeight\n  }\n`;\nexport const MessageProofFragmentFragmentDoc = gql`\n  fragment messageProofFragment on MessageProof {\n    proofSet\n    proofIndex\n    sender\n    recipient\n    nonce\n    amount\n    data\n    signature\n    header {\n      id\n      daHeight\n      transactionsCount\n      outputMessagesCount\n      transactionsRoot\n      outputMessagesRoot\n      height\n      prevRoot\n      time\n      applicationHash\n    }\n  }\n`;\nexport const BalanceFragmentFragmentDoc = gql`\n  fragment balanceFragment on Balance {\n    owner\n    amount\n    assetId\n  }\n`;\nexport const ConsensusParametersFragmentFragmentDoc = gql`\n  fragment consensusParametersFragment on ConsensusParameters {\n    contractMaxSize\n    maxInputs\n    maxOutputs\n    maxWitnesses\n    maxGasPerTx\n    maxScriptLength\n    maxScriptDataLength\n    maxStorageSlots\n    maxPredicateLength\n    maxPredicateDataLength\n    gasPriceFactor\n    gasPerByte\n    maxMessageDataLength\n  }\n`;\nexport const BlockFragmentFragmentDoc = gql`\n  fragment blockFragment on Block {\n    id\n    header {\n      height\n      time\n    }\n    transactions {\n      id\n    }\n  }\n`;\nexport const ChainInfoFragmentFragmentDoc = gql`\n  fragment chainInfoFragment on ChainInfo {\n    name\n    baseChainHeight\n    peerCount\n    consensusParameters {\n      ...consensusParametersFragment\n    }\n    latestBlock {\n      ...blockFragment\n    }\n  }\n  ${ConsensusParametersFragmentFragmentDoc}\n  ${BlockFragmentFragmentDoc}\n`;\nexport const ContractBalanceFragmentFragmentDoc = gql`\n  fragment contractBalanceFragment on ContractBalance {\n    contract\n    amount\n    assetId\n  }\n`;\nexport const GetVersionDocument = gql`\n  query getVersion {\n    nodeInfo {\n      nodeVersion\n    }\n  }\n`;\nexport const GetInfoDocument = gql`\n  query getInfo {\n    nodeInfo {\n      nodeVersion\n      minGasPrice\n    }\n  }\n`;\nexport const GetChainDocument = gql`\n  query getChain {\n    chain {\n      ...chainInfoFragment\n    }\n  }\n  ${ChainInfoFragmentFragmentDoc}\n`;\nexport const GetTransactionDocument = gql`\n  query getTransaction($transactionId: TransactionId!) {\n    transaction(id: $transactionId) {\n      ...transactionFragment\n    }\n  }\n  ${TransactionFragmentFragmentDoc}\n`;\nexport const GetTransactionWithReceiptsDocument = gql`\n  query getTransactionWithReceipts($transactionId: TransactionId!) {\n    transaction(id: $transactionId) {\n      ...transactionFragment\n      receipts {\n        ...receiptFragment\n      }\n    }\n  }\n  ${TransactionFragmentFragmentDoc}\n  ${ReceiptFragmentFragmentDoc}\n`;\nexport const GetTransactionsDocument = gql`\n  query getTransactions($after: String, $before: String, $first: Int, $last: Int) {\n    transactions(after: $after, before: $before, first: $first, last: $last) {\n      edges {\n        node {\n          ...transactionFragment\n        }\n      }\n    }\n  }\n  ${TransactionFragmentFragmentDoc}\n`;\nexport const GetTransactionsByOwnerDocument = gql`\n  query getTransactionsByOwner(\n    $owner: Address!\n    $after: String\n    $before: String\n    $first: Int\n    $last: Int\n  ) {\n    transactionsByOwner(owner: $owner, after: $after, before: $before, first: $first, last: $last) {\n      edges {\n        node {\n          ...transactionFragment\n        }\n      }\n    }\n  }\n  ${TransactionFragmentFragmentDoc}\n`;\nexport const GetBlockDocument = gql`\n  query getBlock($blockId: BlockId, $blockHeight: U64) {\n    block(id: $blockId, height: $blockHeight) {\n      ...blockFragment\n    }\n  }\n  ${BlockFragmentFragmentDoc}\n`;\nexport const GetBlockWithTransactionsDocument = gql`\n  query getBlockWithTransactions($blockId: BlockId, $blockHeight: U64) {\n    block(id: $blockId, height: $blockHeight) {\n      ...blockFragment\n      transactions {\n        ...transactionFragment\n      }\n    }\n  }\n  ${BlockFragmentFragmentDoc}\n  ${TransactionFragmentFragmentDoc}\n`;\nexport const GetBlocksDocument = gql`\n  query getBlocks($after: String, $before: String, $first: Int, $last: Int) {\n    blocks(after: $after, before: $before, first: $first, last: $last) {\n      edges {\n        node {\n          ...blockFragment\n        }\n      }\n    }\n  }\n  ${BlockFragmentFragmentDoc}\n`;\nexport const GetCoinDocument = gql`\n  query getCoin($coinId: UtxoId!) {\n    coin(utxoId: $coinId) {\n      ...coinFragment\n    }\n  }\n  ${CoinFragmentFragmentDoc}\n`;\nexport const GetCoinsDocument = gql`\n  query getCoins(\n    $filter: CoinFilterInput!\n    $after: String\n    $before: String\n    $first: Int\n    $last: Int\n  ) {\n    coins(filter: $filter, after: $after, before: $before, first: $first, last: $last) {\n      edges {\n        node {\n          ...coinFragment\n        }\n      }\n    }\n  }\n  ${CoinFragmentFragmentDoc}\n`;\nexport const GetResourcesToSpendDocument = gql`\n  query getResourcesToSpend(\n    $owner: Address!\n    $queryPerAsset: [SpendQueryElementInput!]!\n    $excludedIds: ExcludeInput\n  ) {\n    resourcesToSpend(owner: $owner, queryPerAsset: $queryPerAsset, excludedIds: $excludedIds) {\n      ...coinFragment\n      ...messageFragment\n    }\n  }\n  ${CoinFragmentFragmentDoc}\n  ${MessageFragmentFragmentDoc}\n`;\nexport const GetContractDocument = gql`\n  query getContract($contractId: ContractId!) {\n    contract(id: $contractId) {\n      bytecode\n      id\n    }\n  }\n`;\nexport const GetContractBalanceDocument = gql`\n  query getContractBalance($contract: ContractId!, $asset: AssetId!) {\n    contractBalance(contract: $contract, asset: $asset) {\n      ...contractBalanceFragment\n    }\n  }\n  ${ContractBalanceFragmentFragmentDoc}\n`;\nexport const GetBalanceDocument = gql`\n  query getBalance($owner: Address!, $assetId: AssetId!) {\n    balance(owner: $owner, assetId: $assetId) {\n      ...balanceFragment\n    }\n  }\n  ${BalanceFragmentFragmentDoc}\n`;\nexport const GetBalancesDocument = gql`\n  query getBalances(\n    $filter: BalanceFilterInput!\n    $after: String\n    $before: String\n    $first: Int\n    $last: Int\n  ) {\n    balances(filter: $filter, after: $after, before: $before, first: $first, last: $last) {\n      edges {\n        node {\n          ...balanceFragment\n        }\n      }\n    }\n  }\n  ${BalanceFragmentFragmentDoc}\n`;\nexport const GetMessagesDocument = gql`\n  query getMessages($owner: Address!, $after: String, $before: String, $first: Int, $last: Int) {\n    messages(owner: $owner, after: $after, before: $before, first: $first, last: $last) {\n      edges {\n        node {\n          ...messageFragment\n        }\n      }\n    }\n  }\n  ${MessageFragmentFragmentDoc}\n`;\nexport const GetMessageProofDocument = gql`\n  query getMessageProof($transactionId: TransactionId!, $messageId: MessageId!) {\n    messageProof(transactionId: $transactionId, messageId: $messageId) {\n      ...messageProofFragment\n    }\n  }\n  ${MessageProofFragmentFragmentDoc}\n`;\nexport const DryRunDocument = gql`\n  mutation dryRun($encodedTransaction: HexString!, $utxoValidation: Boolean) {\n    dryRun(tx: $encodedTransaction, utxoValidation: $utxoValidation) {\n      ...receiptFragment\n    }\n  }\n  ${ReceiptFragmentFragmentDoc}\n`;\nexport const SubmitDocument = gql`\n  mutation submit($encodedTransaction: HexString!) {\n    submit(tx: $encodedTransaction) {\n      id\n    }\n  }\n`;\nexport const StartSessionDocument = gql`\n  mutation startSession {\n    startSession\n  }\n`;\nexport const EndSessionDocument = gql`\n  mutation endSession($sessionId: ID!) {\n    endSession(id: $sessionId)\n  }\n`;\nexport const ExecuteDocument = gql`\n  mutation execute($sessionId: ID!, $op: String!) {\n    execute(id: $sessionId, op: $op)\n  }\n`;\nexport const ResetDocument = gql`\n  mutation reset($sessionId: ID!) {\n    reset(id: $sessionId)\n  }\n`;\n\nexport type SdkFunctionWrapper = <T>(\n  action: (requestHeaders?: Record<string, string>) => Promise<T>,\n  operationName: string,\n  operationType?: string\n) => Promise<T>;\n\nconst defaultWrapper: SdkFunctionWrapper = (action, _operationName, _operationType) => action();\n\nexport function getSdk(client: GraphQLClient, withWrapper: SdkFunctionWrapper = defaultWrapper) {\n  return {\n    getVersion(\n      variables?: GqlGetVersionQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetVersionQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetVersionQuery>(GetVersionDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getVersion',\n        'query'\n      );\n    },\n    getInfo(\n      variables?: GqlGetInfoQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetInfoQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetInfoQuery>(GetInfoDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getInfo',\n        'query'\n      );\n    },\n    getChain(\n      variables?: GqlGetChainQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetChainQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetChainQuery>(GetChainDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getChain',\n        'query'\n      );\n    },\n    getTransaction(\n      variables: GqlGetTransactionQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetTransactionQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetTransactionQuery>(GetTransactionDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getTransaction',\n        'query'\n      );\n    },\n    getTransactionWithReceipts(\n      variables: GqlGetTransactionWithReceiptsQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetTransactionWithReceiptsQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetTransactionWithReceiptsQuery>(\n            GetTransactionWithReceiptsDocument,\n            variables,\n            { ...requestHeaders, ...wrappedRequestHeaders }\n          ),\n        'getTransactionWithReceipts',\n        'query'\n      );\n    },\n    getTransactions(\n      variables?: GqlGetTransactionsQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetTransactionsQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetTransactionsQuery>(GetTransactionsDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getTransactions',\n        'query'\n      );\n    },\n    getTransactionsByOwner(\n      variables: GqlGetTransactionsByOwnerQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetTransactionsByOwnerQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetTransactionsByOwnerQuery>(\n            GetTransactionsByOwnerDocument,\n            variables,\n            { ...requestHeaders, ...wrappedRequestHeaders }\n          ),\n        'getTransactionsByOwner',\n        'query'\n      );\n    },\n    getBlock(\n      variables?: GqlGetBlockQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetBlockQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetBlockQuery>(GetBlockDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getBlock',\n        'query'\n      );\n    },\n    getBlockWithTransactions(\n      variables?: GqlGetBlockWithTransactionsQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetBlockWithTransactionsQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetBlockWithTransactionsQuery>(\n            GetBlockWithTransactionsDocument,\n            variables,\n            { ...requestHeaders, ...wrappedRequestHeaders }\n          ),\n        'getBlockWithTransactions',\n        'query'\n      );\n    },\n    getBlocks(\n      variables?: GqlGetBlocksQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetBlocksQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetBlocksQuery>(GetBlocksDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getBlocks',\n        'query'\n      );\n    },\n    getCoin(\n      variables: GqlGetCoinQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetCoinQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetCoinQuery>(GetCoinDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getCoin',\n        'query'\n      );\n    },\n    getCoins(\n      variables: GqlGetCoinsQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetCoinsQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetCoinsQuery>(GetCoinsDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getCoins',\n        'query'\n      );\n    },\n    getResourcesToSpend(\n      variables: GqlGetResourcesToSpendQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetResourcesToSpendQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetResourcesToSpendQuery>(GetResourcesToSpendDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getResourcesToSpend',\n        'query'\n      );\n    },\n    getContract(\n      variables: GqlGetContractQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetContractQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetContractQuery>(GetContractDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getContract',\n        'query'\n      );\n    },\n    getContractBalance(\n      variables: GqlGetContractBalanceQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetContractBalanceQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetContractBalanceQuery>(GetContractBalanceDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getContractBalance',\n        'query'\n      );\n    },\n    getBalance(\n      variables: GqlGetBalanceQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetBalanceQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetBalanceQuery>(GetBalanceDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getBalance',\n        'query'\n      );\n    },\n    getBalances(\n      variables: GqlGetBalancesQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetBalancesQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetBalancesQuery>(GetBalancesDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getBalances',\n        'query'\n      );\n    },\n    getMessages(\n      variables: GqlGetMessagesQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetMessagesQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetMessagesQuery>(GetMessagesDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getMessages',\n        'query'\n      );\n    },\n    getMessageProof(\n      variables: GqlGetMessageProofQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetMessageProofQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetMessageProofQuery>(GetMessageProofDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getMessageProof',\n        'query'\n      );\n    },\n    dryRun(\n      variables: GqlDryRunMutationVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlDryRunMutation> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlDryRunMutation>(DryRunDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'dryRun',\n        'mutation'\n      );\n    },\n    submit(\n      variables: GqlSubmitMutationVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlSubmitMutation> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlSubmitMutation>(SubmitDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'submit',\n        'mutation'\n      );\n    },\n    startSession(\n      variables?: GqlStartSessionMutationVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlStartSessionMutation> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlStartSessionMutation>(StartSessionDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'startSession',\n        'mutation'\n      );\n    },\n    endSession(\n      variables: GqlEndSessionMutationVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlEndSessionMutation> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlEndSessionMutation>(EndSessionDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'endSession',\n        'mutation'\n      );\n    },\n    execute(\n      variables: GqlExecuteMutationVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlExecuteMutation> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlExecuteMutation>(ExecuteDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'execute',\n        'mutation'\n      );\n    },\n    reset(\n      variables: GqlResetMutationVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlResetMutation> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlResetMutation>(ResetDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'reset',\n        'mutation'\n      );\n    },\n  };\n}\nexport type Sdk = ReturnType<typeof getSdk>;\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport type { BytesLike } from '@ethersproject/bytes';\nimport { arrayify, hexlify } from '@ethersproject/bytes';\nimport type { Network } from '@ethersproject/networks';\nimport { Address } from '@fuel-ts/address';\nimport type { AbstractAddress } from '@fuel-ts/interfaces';\nimport type { BN } from '@fuel-ts/math';\nimport { max, bn } from '@fuel-ts/math';\nimport type { Transaction } from '@fuel-ts/transactions';\nimport {\n  TransactionType,\n  InputMessageCoder,\n  ReceiptType,\n  ReceiptCoder,\n  TransactionCoder,\n} from '@fuel-ts/transactions';\nimport { MAX_GAS_PER_TX } from '@fuel-ts/transactions/configs';\nimport { GraphQLClient } from 'graphql-request';\nimport cloneDeep from 'lodash.clonedeep';\n\nimport type {\n  GqlChainInfoFragmentFragment,\n  GqlGetInfoQuery,\n  GqlReceiptFragmentFragment,\n} from './__generated__/operations';\nimport { getSdk as getOperationsSdk } from './__generated__/operations';\nimport type { Coin } from './coin';\nimport type { CoinQuantity, CoinQuantityLike } from './coin-quantity';\nimport { coinQuantityfy } from './coin-quantity';\nimport type { Message, MessageProof } from './message';\nimport type { ExcludeResourcesOption, Resource } from './resource';\nimport { isRawCoin } from './resource';\nimport { transactionRequestify } from './transaction-request';\nimport type { TransactionRequestLike, TransactionRequest } from './transaction-request';\nimport type { TransactionResultReceipt } from './transaction-response/transaction-response';\nimport { TransactionResponse } from './transaction-response/transaction-response';\nimport { calculateTransactionFee, getReceiptsWithMissingData } from './utils';\n\nconst MAX_RETRIES = 10;\n\nexport type CallResult = {\n  receipts: TransactionResultReceipt[];\n};\n\n/**\n * A Fuel block\n */\nexport type Block = {\n  id: string;\n  height: BN;\n  time: string;\n  transactionIds: string[];\n};\n\n/**\n * Deployed Contract bytecode and contract id\n */\nexport type ContractResult = {\n  id: string;\n  bytecode: string;\n};\n\n/**\n * Chain information\n */\nexport type ChainInfo = {\n  name: string;\n  baseChainHeight: BN;\n  peerCount: number;\n  consensusParameters: {\n    contractMaxSize: BN;\n    maxInputs: BN;\n    maxOutputs: BN;\n    maxWitnesses: BN;\n    maxGasPerTx: BN;\n    maxScriptLength: BN;\n    maxScriptDataLength: BN;\n    maxStorageSlots: BN;\n    maxPredicateLength: BN;\n    maxPredicateDataLength: BN;\n    gasPriceFactor: BN;\n    gasPerByte: BN;\n    maxMessageDataLength: BN;\n  };\n  latestBlock: {\n    id: string;\n    height: BN;\n    time: string;\n    transactions: Array<{ id: string }>;\n  };\n};\n\n/**\n * Node information\n */\nexport type NodeInfo = {\n  minGasPrice: BN;\n  nodeVersion: string;\n};\n\nexport type TransactionCost = {\n  minGasPrice: BN;\n  gasPrice: BN;\n  gasUsed: BN;\n  fee: BN;\n};\n\nconst processGqlReceipt = (gqlReceipt: GqlReceiptFragmentFragment): TransactionResultReceipt => {\n  const receipt = new ReceiptCoder().decode(arrayify(gqlReceipt.rawPayload), 0)[0];\n\n  switch (receipt.type) {\n    case ReceiptType.ReturnData: {\n      return {\n        ...receipt,\n        data: gqlReceipt.data!,\n      };\n    }\n    case ReceiptType.LogData: {\n      return {\n        ...receipt,\n        data: gqlReceipt.data!,\n      };\n    }\n    default:\n      return receipt;\n  }\n};\n\nconst processGqlChain = (chain: GqlChainInfoFragmentFragment): ChainInfo => {\n  const { name, baseChainHeight, peerCount, consensusParameters, latestBlock } = chain;\n\n  return {\n    name,\n    baseChainHeight: bn(baseChainHeight),\n    peerCount,\n    consensusParameters: {\n      contractMaxSize: bn(consensusParameters.contractMaxSize),\n      maxInputs: bn(consensusParameters.maxInputs),\n      maxOutputs: bn(consensusParameters.maxOutputs),\n      maxWitnesses: bn(consensusParameters.maxWitnesses),\n      maxGasPerTx: bn(consensusParameters.maxGasPerTx),\n      maxScriptLength: bn(consensusParameters.maxScriptLength),\n      maxScriptDataLength: bn(consensusParameters.maxScriptDataLength),\n      maxStorageSlots: bn(consensusParameters.maxStorageSlots),\n      maxPredicateLength: bn(consensusParameters.maxPredicateLength),\n      maxPredicateDataLength: bn(consensusParameters.maxPredicateDataLength),\n      gasPriceFactor: bn(consensusParameters.gasPriceFactor),\n      gasPerByte: bn(consensusParameters.gasPerByte),\n      maxMessageDataLength: bn(consensusParameters.maxMessageDataLength),\n    },\n    latestBlock: {\n      id: latestBlock.id,\n      height: bn(latestBlock.header.height),\n      time: latestBlock.header.time,\n      transactions: latestBlock.transactions.map((i) => ({\n        id: i.id,\n      })),\n    },\n  };\n};\n\nconst processNodeInfo = (nodeInfo: GqlGetInfoQuery['nodeInfo']) => ({\n  minGasPrice: bn(nodeInfo.minGasPrice),\n  nodeVersion: nodeInfo.nodeVersion,\n});\n\n/**\n * Cursor pagination arguments\n *\n * https://relay.dev/graphql/connections.htm#sec-Arguments\n */\nexport type CursorPaginationArgs = {\n  /** Forward pagination limit */\n  first?: number | null;\n  /** Forward pagination cursor */\n  after?: string | null;\n  /** Backward pagination limit  */\n  last?: number | null;\n  /** Backward pagination cursor */\n  before?: string | null;\n};\n\nexport type BuildPredicateOptions = {\n  fundTransaction?: boolean;\n} & Pick<TransactionRequestLike, 'gasLimit' | 'gasPrice' | 'maturity'>;\n\nexport type FetchRequestOptions = {\n  method: 'POST';\n  headers: { [key: string]: string };\n  body: string;\n};\n\n/*\n * Provider initialization options\n */\nexport type ProviderOptions = {\n  fetch?: (url: string, options: FetchRequestOptions) => Promise<any>;\n};\n\n/**\n * Provider Call transaction params\n */\nexport type ProviderCallParams = {\n  utxoValidation?: boolean;\n};\n/**\n * A provider for connecting to a Fuel node\n */\nexport default class Provider {\n  operations: ReturnType<typeof getOperationsSdk>;\n\n  constructor(\n    /** GraphQL endpoint of the Fuel node */\n    public url: string,\n    public options: ProviderOptions = {}\n  ) {\n    this.operations = this.createOperations(url, options);\n  }\n\n  /**\n   * Create GraphQL client and set operations\n   */\n  private createOperations(url: string, options: ProviderOptions = {}) {\n    this.url = url;\n    const gqlClient = new GraphQLClient(url, options.fetch ? { fetch: options.fetch } : undefined);\n    return getOperationsSdk(gqlClient);\n  }\n\n  /**\n   * Connect provider to a different Fuel node url\n   */\n  connect(url: string) {\n    this.operations = this.createOperations(url);\n  }\n\n  /**\n   * Returns the version of the connected Fuel node\n   */\n  async getVersion(): Promise<string> {\n    const {\n      nodeInfo: { nodeVersion },\n    } = await this.operations.getVersion();\n    return nodeVersion;\n  }\n\n  /**\n   * Returns the network configuration of the connected Fuel node\n   */\n  async getNetwork(): Promise<Network> {\n    return Promise.resolve({\n      name: 'fuelv2',\n      chainId: 0xdeadbeef,\n    });\n  }\n\n  /**\n   * Returns the current block number\n   */\n  async getBlockNumber(): Promise<BN> {\n    const { chain } = await this.operations.getChain();\n    return bn(chain.latestBlock.header.height, 10);\n  }\n\n  /**\n   * Returns node information\n   */\n  async getNodeInfo(): Promise<NodeInfo> {\n    const { nodeInfo } = await this.operations.getInfo();\n    return processNodeInfo(nodeInfo);\n  }\n\n  /**\n   * Returns chain information\n   */\n  async getChain(): Promise<ChainInfo> {\n    const { chain } = await this.operations.getChain();\n    return processGqlChain(chain);\n  }\n\n  /**\n   * Submits a transaction to the chain to be executed\n   * If the transaction is missing VariableOuputs\n   * the transaction will be mutate and VariableOuputs will be added\n   */\n  async sendTransaction(\n    transactionRequestLike: TransactionRequestLike\n  ): Promise<TransactionResponse> {\n    const transactionRequest = transactionRequestify(transactionRequestLike);\n    await this.addMissingVariables(transactionRequest);\n\n    const encodedTransaction = hexlify(transactionRequest.toTransactionBytes());\n    const { gasUsed, minGasPrice } = await this.getTransactionCost(transactionRequest, 0);\n\n    // Fail transaction before submit to avoid submit failure\n    // Resulting in lost of funds on a OutOfGas situation.\n    if (bn(gasUsed).gt(bn(transactionRequest.gasLimit))) {\n      throw new Error(\n        `gasLimit(${transactionRequest.gasLimit}) is lower than the required (${gasUsed})`\n      );\n    } else if (bn(minGasPrice).gt(bn(transactionRequest.gasPrice))) {\n      throw new Error(\n        `gasPrice(${transactionRequest.gasPrice}) is lower than the required ${minGasPrice}`\n      );\n    }\n\n    const {\n      submit: { id: transactionId },\n    } = await this.operations.submit({ encodedTransaction });\n\n    const response = new TransactionResponse(transactionId, this);\n    return response;\n  }\n\n  /**\n   * Executes a transaction without actually submitting it to the chain\n   * If the transaction is missing VariableOuputs\n   * the transaction will be mutate and VariableOuputs will be added\n   */\n  async call(\n    transactionRequestLike: TransactionRequestLike,\n    { utxoValidation }: ProviderCallParams = {}\n  ): Promise<CallResult> {\n    const transactionRequest = transactionRequestify(transactionRequestLike);\n    await this.addMissingVariables(transactionRequest);\n    const encodedTransaction = hexlify(transactionRequest.toTransactionBytes());\n    const { dryRun: gqlReceipts } = await this.operations.dryRun({\n      encodedTransaction,\n      utxoValidation: utxoValidation || false,\n    });\n    const receipts = gqlReceipts.map(processGqlReceipt);\n    return {\n      receipts,\n    };\n  }\n\n  /**\n   * Will dryRun a transaction and check for missing VariableOutputs\n   *\n   * If there are missing VariableOutputs\n   * `addVariableOutputs` is called on the transaction.\n   * This process is done at most 10 times\n   */\n  async addMissingVariables(transactionRequest: TransactionRequest): Promise<void> {\n    let missingOutputVariableCount = 0;\n    let missingOutputContractIdsCount = 0;\n    let tries = 0;\n\n    if (transactionRequest.type === TransactionType.Create) {\n      return;\n    }\n\n    do {\n      const encodedTransaction = hexlify(transactionRequest.toTransactionBytes());\n      const { dryRun: gqlReceipts } = await this.operations.dryRun({\n        encodedTransaction,\n        utxoValidation: false,\n      });\n      const receipts = gqlReceipts.map(processGqlReceipt);\n      const { missingOutputVariables, missingOutputContractIds } =\n        getReceiptsWithMissingData(receipts);\n\n      missingOutputVariableCount = missingOutputVariables.length;\n      missingOutputContractIdsCount = missingOutputContractIds.length;\n\n      if (missingOutputVariableCount === 0 && missingOutputContractIdsCount === 0) {\n        return;\n      }\n\n      transactionRequest.addVariableOutputs(missingOutputVariableCount);\n\n      missingOutputContractIds.forEach(({ contractId }) =>\n        transactionRequest.addContract(Address.fromString(contractId))\n      );\n      tries += 1;\n    } while (tries < MAX_RETRIES);\n  }\n\n  /**\n   * Executes a signed transaction without applying the states changes\n   * on the chain.\n   * If the transaction is missing VariableOuputs\n   * the transaction will be mutate and VariableOuputs will be added\n   */\n  async simulate(transactionRequestLike: TransactionRequestLike): Promise<CallResult> {\n    const transactionRequest = transactionRequestify(transactionRequestLike);\n    await this.addMissingVariables(transactionRequest);\n    const encodedTransaction = hexlify(transactionRequest.toTransactionBytes());\n    const { dryRun: gqlReceipts } = await this.operations.dryRun({\n      encodedTransaction,\n      utxoValidation: true,\n    });\n    const receipts = gqlReceipts.map(processGqlReceipt);\n    return {\n      receipts,\n    };\n  }\n\n  /**\n   * Returns a transaction cost to enable user\n   * to set gasLimit and also reserve balance amounts\n   * on the the transaction.\n   *\n   * The tolerance is add on top of the gasUsed calculated\n   * from the node, this create a safe margin costs like\n   * change states on transfer that don't occur on the dryRun\n   * transaction. The default value is 0.2 or 20%\n   */\n  async getTransactionCost(\n    transactionRequestLike: TransactionRequestLike,\n    tolerance: number = 0.2\n  ): Promise<TransactionCost> {\n    const transactionRequest = transactionRequestify(cloneDeep(transactionRequestLike));\n    const { minGasPrice } = await this.getNodeInfo();\n    const gasPrice = max(transactionRequest.gasPrice, minGasPrice);\n    const margin = 1 + tolerance;\n\n    // Set gasLimit to the maximum of the chain\n    // and gasPrice to 0 for measure\n    // Transaction without arrive to OutOfGas\n    transactionRequest.gasLimit = MAX_GAS_PER_TX;\n    transactionRequest.gasPrice = bn(0);\n\n    // Execute dryRun not validated transaction to query gasUsed\n    const { receipts } = await this.call(transactionRequest);\n    const { gasUsed, fee } = calculateTransactionFee({\n      gasPrice,\n      receipts,\n      margin,\n    });\n\n    return {\n      minGasPrice,\n      gasPrice,\n      gasUsed,\n      fee,\n    };\n  }\n\n  /**\n   * Returns coins for the given owner\n   */\n  async getCoins(\n    /** The address to get coins for */\n    owner: AbstractAddress,\n    /** The asset ID of coins to get */\n    assetId?: BytesLike,\n    /** Pagination arguments */\n    paginationArgs?: CursorPaginationArgs\n  ): Promise<Coin[]> {\n    const result = await this.operations.getCoins({\n      first: 10,\n      ...paginationArgs,\n      filter: { owner: owner.toB256(), assetId: assetId && hexlify(assetId) },\n    });\n\n    const coins = result.coins.edges!.map((edge) => edge!.node!);\n\n    return coins.map((coin) => ({\n      id: coin.utxoId,\n      assetId: coin.assetId,\n      amount: bn(coin.amount),\n      owner: Address.fromAddressOrString(coin.owner),\n      status: coin.coinStatus,\n      maturity: bn(coin.maturity).toNumber(),\n      blockCreated: bn(coin.blockCreated),\n    }));\n  }\n\n  /**\n   * Returns resources for the given owner satisfying the spend query\n   */\n  async getResourcesToSpend(\n    /** The address to get coins for */\n    owner: AbstractAddress,\n    /** The quantities to get */\n    quantities: CoinQuantityLike[],\n    /** IDs of excluded resources from the selection. */\n    excludedIds?: ExcludeResourcesOption\n  ): Promise<Resource[]> {\n    const excludeInput = {\n      messages: excludedIds?.messages?.map((id) => hexlify(id)) || [],\n      utxos: excludedIds?.utxos?.map((id) => hexlify(id)) || [],\n    };\n    const result = await this.operations.getResourcesToSpend({\n      owner: owner.toB256(),\n      queryPerAsset: quantities\n        .map(coinQuantityfy)\n        .map(({ assetId, amount, max: maxPerAsset }) => ({\n          assetId: hexlify(assetId),\n          amount: amount.toString(10),\n          max: maxPerAsset ? maxPerAsset.toString(10) : undefined,\n        })),\n      excludedIds: excludeInput,\n    });\n\n    return result.resourcesToSpend.flat().map((resource) => {\n      if (isRawCoin(resource)) {\n        return {\n          id: resource.utxoId,\n          amount: bn(resource.amount),\n          status: resource.coinStatus,\n          assetId: resource.assetId,\n          owner: Address.fromAddressOrString(resource.owner),\n          maturity: bn(resource.maturity).toNumber(),\n          blockCreated: bn(resource.blockCreated),\n        };\n      }\n\n      return {\n        sender: Address.fromAddressOrString(resource.sender),\n        recipient: Address.fromAddressOrString(resource.recipient),\n        nonce: bn(resource.nonce),\n        amount: bn(resource.amount),\n        data: InputMessageCoder.decodeData(resource.data),\n        status: resource.messageStatus,\n        daHeight: bn(resource.daHeight),\n      };\n    });\n  }\n\n  /**\n   * Returns block matching the given ID or type\n   */\n  async getBlock(\n    /** ID or height of the block */\n    idOrHeight: string | number | 'latest'\n  ): Promise<Block | null> {\n    let variables;\n    if (typeof idOrHeight === 'number') {\n      variables = { blockHeight: bn(idOrHeight).toString(10) };\n    } else if (idOrHeight === 'latest') {\n      variables = { blockHeight: (await this.getBlockNumber()).toString(10) };\n    } else {\n      variables = { blockId: bn(idOrHeight).toString(10) };\n    }\n\n    const { block } = await this.operations.getBlock(variables);\n\n    if (!block) {\n      return null;\n    }\n\n    return {\n      id: block.id,\n      height: bn(block.header.height),\n      time: block.header.time,\n      transactionIds: block.transactions.map((tx) => tx.id),\n    };\n  }\n\n  /**\n   * Returns block matching the given ID or type, including transaction data\n   */\n  async getBlockWithTransactions(\n    /** ID or height of the block */\n    idOrHeight: string | number | 'latest'\n  ): Promise<(Block & { transactions: Transaction[] }) | null> {\n    let variables;\n    if (typeof idOrHeight === 'number') {\n      variables = { blockHeight: bn(idOrHeight).toString(10) };\n    } else if (idOrHeight === 'latest') {\n      variables = { blockHeight: (await this.getBlockNumber()).toString() };\n    } else {\n      variables = { blockId: idOrHeight };\n    }\n\n    const { block } = await this.operations.getBlockWithTransactions(variables);\n\n    if (!block) {\n      return null;\n    }\n\n    return {\n      id: block.id,\n      height: bn(block.header.height, 10),\n      time: block.header.time,\n      transactionIds: block.transactions.map((tx) => tx.id),\n      transactions: block.transactions.map(\n        (tx) => new TransactionCoder().decode(arrayify(tx.rawPayload), 0)?.[0]\n      ),\n    };\n  }\n\n  /**\n   * Get transaction with the given ID\n   */\n  async getTransaction<TTransactionType = void>(\n    transactionId: string\n  ): Promise<Transaction<TTransactionType> | null> {\n    const { transaction } = await this.operations.getTransaction({ transactionId });\n    if (!transaction) {\n      return null;\n    }\n    return new TransactionCoder().decode(\n      arrayify(transaction.rawPayload),\n      0\n    )?.[0] as Transaction<TTransactionType>;\n  }\n\n  /**\n   * Get deployed contract with the given ID\n   *\n   * @returns contract bytecode and contract id\n   */\n  async getContract(contractId: string): Promise<ContractResult | null> {\n    const { contract } = await this.operations.getContract({ contractId });\n    if (!contract) {\n      return null;\n    }\n    return contract;\n  }\n\n  /**\n   * Returns the balance for the given contract for the given asset ID\n   */\n  async getContractBalance(\n    /** The contract ID to get the balance for */\n    contractId: AbstractAddress,\n    /** The asset ID of coins to get */\n    assetId: BytesLike\n  ): Promise<BN> {\n    const { contractBalance } = await this.operations.getContractBalance({\n      contract: contractId.toB256(),\n      asset: hexlify(assetId),\n    });\n    return bn(contractBalance.amount, 10);\n  }\n\n  /**\n   * Returns the balance for the given owner for the given asset ID\n   */\n  async getBalance(\n    /** The address to get coins for */\n    owner: AbstractAddress,\n    /** The asset ID of coins to get */\n    assetId: BytesLike\n  ): Promise<BN> {\n    const { balance } = await this.operations.getBalance({\n      owner: owner.toB256(),\n      assetId: hexlify(assetId),\n    });\n    return bn(balance.amount, 10);\n  }\n\n  /**\n   * Returns balances for the given owner\n   */\n  async getBalances(\n    /** The address to get coins for */\n    owner: AbstractAddress,\n    /** Pagination arguments */\n    paginationArgs?: CursorPaginationArgs\n  ): Promise<CoinQuantity[]> {\n    const result = await this.operations.getBalances({\n      first: 10,\n      ...paginationArgs,\n      filter: { owner: owner.toB256() },\n    });\n\n    const balances = result.balances.edges!.map((edge) => edge!.node!);\n\n    return balances.map((balance) => ({\n      assetId: balance.assetId,\n      amount: bn(balance.amount),\n    }));\n  }\n\n  /**\n   * Returns message for the given address\n   */\n  async getMessages(\n    /** The address to get message from */\n    address: AbstractAddress,\n    /** Pagination arguments */\n    paginationArgs?: CursorPaginationArgs\n  ): Promise<Message[]> {\n    const result = await this.operations.getMessages({\n      first: 10,\n      ...paginationArgs,\n      owner: address.toB256(),\n    });\n\n    const messages = result.messages.edges!.map((edge) => edge!.node!);\n\n    return messages.map((message) => ({\n      sender: Address.fromAddressOrString(message.sender),\n      recipient: Address.fromAddressOrString(message.recipient),\n      nonce: bn(message.nonce),\n      amount: bn(message.amount),\n      data: InputMessageCoder.decodeData(message.data),\n      status: message.messageStatus,\n      daHeight: bn(message.daHeight),\n    }));\n  }\n\n  /**\n   * Returns Message Proof for given transaction id and the message id from MessageOut receipt\n   */\n  async getMessageProof(\n    /** The transaction to get message from */\n    transactionId: string,\n    /** The message id from MessageOut receipt */\n    messageId: string\n  ): Promise<MessageProof | null> {\n    const result = await this.operations.getMessageProof({\n      transactionId,\n      messageId,\n    });\n\n    if (!result.messageProof) {\n      return null;\n    }\n\n    return {\n      proofSet: result.messageProof.proofSet,\n      proofIndex: bn(result.messageProof.proofIndex),\n      sender: Address.fromAddressOrString(result.messageProof.sender),\n      recipient: Address.fromAddressOrString(result.messageProof.recipient),\n      nonce: result.messageProof.nonce,\n      amount: bn(result.messageProof.amount),\n      data: result.messageProof.data,\n      signature: result.messageProof.signature,\n      header: {\n        id: result.messageProof.header.id,\n        daHeight: bn(result.messageProof.header.daHeight),\n        transactionsCount: bn(result.messageProof.header.transactionsCount),\n        outputMessagesCount: bn(result.messageProof.header.outputMessagesCount),\n        transactionsRoot: result.messageProof.header.transactionsRoot,\n        outputMessagesRoot: result.messageProof.header.outputMessagesRoot,\n        height: bn(result.messageProof.header.height),\n        prevRoot: result.messageProof.header.prevRoot,\n        time: result.messageProof.header.time,\n        applicationHash: result.messageProof.header.applicationHash,\n      },\n    };\n  }\n}\n","import type { BytesLike } from '@ethersproject/bytes';\n\nimport type {\n  GqlGetResourcesToSpendQuery,\n  GqlCoinStatus,\n  GqlMessageStatus,\n} from './__generated__/operations';\nimport type { Coin } from './coin';\nimport type { Message } from './message';\n\nexport type RawCoin = {\n  utxoId: string;\n  owner: string;\n  amount: string;\n  assetId: string;\n  maturity: string;\n  coinStatus: GqlCoinStatus;\n  blockCreated: string;\n};\n\nexport type RawMessage = {\n  amount: string;\n  sender: string;\n  recipient: string;\n  data: string;\n  nonce: string;\n  messageStatus: GqlMessageStatus;\n  daHeight: string;\n};\n\nexport type RawResource = RawCoin | RawMessage;\nexport type Resource = Coin | Message;\n\nexport type Resources = GqlGetResourcesToSpendQuery['resourcesToSpend'];\n\nexport type ExcludeResourcesOption = {\n  utxos?: BytesLike[];\n  messages?: BytesLike[];\n};\n\nexport const isRawCoin = (resource: RawResource): resource is RawCoin => 'utxoId' in resource;\nexport const isRawMessage = (resource: RawResource): resource is RawMessage =>\n  'recipient' in resource;\n\nexport const isCoin = (resource: Resource): resource is Coin => 'id' in resource;\nexport const isMessage = (resource: Resource): resource is Message => 'recipient' in resource;\n","import type { BytesLike } from '@ethersproject/bytes';\nimport { arrayify, hexlify } from '@ethersproject/bytes';\nimport { ZeroBytes32 } from '@fuel-ts/address/configs';\nimport type { BigNumberish } from '@fuel-ts/math';\nimport { bn, toNumber } from '@fuel-ts/math';\nimport type { Input } from '@fuel-ts/transactions';\nimport { InputType } from '@fuel-ts/transactions';\n\nexport type CoinTransactionRequestInput = {\n  type: InputType.Coin;\n\n  /** UTXO ID */\n  id: BytesLike;\n\n  /** Owning address or script hash */\n  owner: BytesLike;\n\n  /** Amount of coins */\n  amount: BigNumberish;\n\n  /** Asset ID of the coins */\n  assetId: BytesLike;\n\n  /** Points to the TX whose output is being spent. (TxPointer) */\n  txPointer: BytesLike;\n\n  /** Index of witness that authorizes spending the coin */\n  witnessIndex: number;\n\n  /** UTXO being spent must have been created at least this many blocks ago */\n  maturity?: number;\n\n  /** Predicate bytecode */\n  predicate?: BytesLike;\n\n  /** Predicate input data (parameters) */\n  predicateData?: BytesLike;\n};\nexport type MessageTransactionRequestInput = {\n  type: InputType.Message;\n\n  /** Amount of coins */\n  amount: BigNumberish;\n\n  /** Address of sender */\n  sender: BytesLike;\n\n  /** Address of sender */\n  recipient: BytesLike;\n\n  /** Index of witness that authorizes the message */\n  witnessIndex: number;\n\n  /** data of message */\n  data: BytesLike;\n\n  /** Unique nonce of message */\n  nonce: BigNumberish;\n\n  /** Predicate bytecode */\n  predicate?: BytesLike;\n\n  /** Predicate input data (parameters) */\n  predicateData?: BytesLike;\n};\nexport type ContractTransactionRequestInput = {\n  type: InputType.Contract;\n\n  /** Points to the TX whose output is being spent. (TxPointer) */\n  txPointer: BytesLike;\n\n  /** Contract ID */\n  contractId: BytesLike;\n};\nexport type TransactionRequestInput =\n  | CoinTransactionRequestInput\n  | ContractTransactionRequestInput\n  | MessageTransactionRequestInput;\n\nexport const inputify = (value: TransactionRequestInput): Input => {\n  switch (value.type) {\n    case InputType.Coin: {\n      const predicate = arrayify(value.predicate ?? '0x');\n      const predicateData = arrayify(value.predicateData ?? '0x');\n      return {\n        type: InputType.Coin,\n        utxoID: {\n          transactionId: hexlify(arrayify(value.id).slice(0, 32)),\n          outputIndex: arrayify(value.id)[32],\n        },\n        owner: hexlify(value.owner),\n        amount: bn(value.amount),\n        assetId: hexlify(value.assetId),\n        txPointer: {\n          blockHeight: toNumber(arrayify(value.txPointer).slice(0, 8)),\n          txIndex: toNumber(arrayify(value.txPointer).slice(8, 16)),\n        },\n        witnessIndex: value.witnessIndex,\n        maturity: value.maturity ?? 0,\n        predicateLength: predicate.length,\n        predicateDataLength: predicateData.length,\n        predicate: hexlify(predicate),\n        predicateData: hexlify(predicateData),\n      };\n    }\n    case InputType.Contract: {\n      return {\n        type: InputType.Contract,\n        utxoID: {\n          transactionId: ZeroBytes32,\n          outputIndex: 0,\n        },\n        balanceRoot: ZeroBytes32,\n        stateRoot: ZeroBytes32,\n        txPointer: {\n          blockHeight: toNumber(arrayify(value.txPointer).slice(0, 8)),\n          txIndex: toNumber(arrayify(value.txPointer).slice(8, 16)),\n        },\n        contractID: hexlify(value.contractId),\n      };\n    }\n    case InputType.Message: {\n      const predicate = arrayify(value.predicate ?? '0x');\n      const predicateData = arrayify(value.predicateData ?? '0x');\n      return {\n        type: InputType.Message,\n        sender: hexlify(value.sender),\n        recipient: hexlify(value.recipient),\n        amount: bn(value.amount),\n        nonce: bn(value.nonce),\n        witnessIndex: value.witnessIndex,\n        dataLength: value.data.length,\n        predicateLength: predicate.length,\n        predicateDataLength: predicateData.length,\n        data: hexlify(value.data),\n        predicate: hexlify(predicate),\n        predicateData: hexlify(predicateData),\n      };\n    }\n    default: {\n      throw new Error('Invalid Input type');\n    }\n  }\n};\n","import type { BytesLike } from '@ethersproject/bytes';\nimport { hexlify } from '@ethersproject/bytes';\nimport { ZeroBytes32 } from '@fuel-ts/address/configs';\nimport type { BigNumberish } from '@fuel-ts/math';\nimport { bn } from '@fuel-ts/math';\nimport type { Output } from '@fuel-ts/transactions';\nimport { OutputType } from '@fuel-ts/transactions';\n\nexport type CoinTransactionRequestOutput = {\n  type: OutputType.Coin;\n  /** Receiving address or script hash */\n  to: BytesLike;\n  /** Amount of coins to send */\n  amount: BigNumberish;\n  /** Asset ID of coins */\n  assetId: BytesLike;\n};\nexport type ContractTransactionRequestOutput = {\n  type: OutputType.Contract;\n  /** Index of input contract */\n  inputIndex: number;\n};\nexport type MessageTransactionRequestOutput = {\n  type: OutputType.Message;\n  /** Receiving address */\n  recipient: BytesLike;\n  /** Amount of coins sent with message */\n  amount: BigNumberish;\n};\nexport type ChangeTransactionRequestOutput = {\n  type: OutputType.Change;\n  /** Receiving address or script hash */\n  to: BytesLike;\n  /** Asset ID of coins */\n  assetId: BytesLike;\n};\nexport type VariableTransactionRequestOutput = {\n  type: OutputType.Variable;\n};\nexport type ContractCreatedTransactionRequestOutput = {\n  type: OutputType.ContractCreated;\n  /** Contract ID */\n  contractId: BytesLike;\n  /** State Root */\n  stateRoot: BytesLike;\n};\nexport type TransactionRequestOutput =\n  | CoinTransactionRequestOutput\n  | ContractTransactionRequestOutput\n  | MessageTransactionRequestOutput\n  | ChangeTransactionRequestOutput\n  | VariableTransactionRequestOutput\n  | ContractCreatedTransactionRequestOutput;\n\nexport const outputify = (value: TransactionRequestOutput): Output => {\n  switch (value.type) {\n    case OutputType.Coin: {\n      return {\n        type: OutputType.Coin,\n        to: hexlify(value.to),\n        amount: bn(value.amount),\n        assetId: hexlify(value.assetId),\n      };\n    }\n    case OutputType.Contract: {\n      return {\n        type: OutputType.Contract,\n        inputIndex: value.inputIndex,\n        balanceRoot: ZeroBytes32,\n        stateRoot: ZeroBytes32,\n      };\n    }\n    case OutputType.Message: {\n      return {\n        type: OutputType.Message,\n        recipient: hexlify(value.recipient),\n        amount: bn(value.amount),\n      };\n    }\n    case OutputType.Change: {\n      return {\n        type: OutputType.Change,\n        to: hexlify(value.to),\n        amount: bn(0),\n        assetId: hexlify(value.assetId),\n      };\n    }\n    case OutputType.Variable: {\n      return {\n        type: OutputType.Variable,\n        to: ZeroBytes32,\n        amount: bn(0),\n        assetId: ZeroBytes32,\n      };\n    }\n    case OutputType.ContractCreated: {\n      return {\n        type: OutputType.ContractCreated,\n        contractId: hexlify(value.contractId),\n        stateRoot: hexlify(value.stateRoot),\n      };\n    }\n    default: {\n      throw new Error('Invalid Output type');\n    }\n  }\n};\n","/* eslint-disable max-classes-per-file */\nimport type { BytesLike } from '@ethersproject/bytes';\nimport { arrayify, hexlify } from '@ethersproject/bytes';\nimport { addressify } from '@fuel-ts/address';\nimport { ZeroBytes32, NativeAssetId } from '@fuel-ts/address/configs';\nimport type {\n  AddressLike,\n  AbstractAddress,\n  ContractIdLike,\n  AbstractScriptRequest,\n} from '@fuel-ts/interfaces';\nimport type { BigNumberish, BN } from '@fuel-ts/math';\nimport { bn } from '@fuel-ts/math';\nimport type { TransactionCreate, TransactionScript } from '@fuel-ts/transactions';\nimport { TransactionType, TransactionCoder, InputType, OutputType } from '@fuel-ts/transactions';\nimport { GAS_PRICE_FACTOR } from '@fuel-ts/transactions/configs';\n\nimport type { CoinQuantity, CoinQuantityLike } from '../coin-quantity';\nimport { coinQuantityfy } from '../coin-quantity';\nimport type { Resource } from '../resource';\nimport { isCoin } from '../resource';\nimport { calculatePriceWithFactor, normalizeJSON } from '../utils';\n\nimport type {\n  CoinTransactionRequestOutput,\n  ContractCreatedTransactionRequestOutput,\n  ContractTransactionRequestOutput,\n  VariableTransactionRequestOutput,\n} from '.';\nimport type {\n  TransactionRequestInput,\n  CoinTransactionRequestInput,\n  ContractTransactionRequestInput,\n  MessageTransactionRequestInput,\n} from './input';\nimport { inputify } from './input';\nimport type { TransactionRequestOutput, ChangeTransactionRequestOutput } from './output';\nimport { outputify } from './output';\nimport type { TransactionRequestStorageSlot } from './storage-slot';\nimport { storageSlotify } from './storage-slot';\nimport type { TransactionRequestWitness } from './witness';\nimport { witnessify } from './witness';\n\nexport { TransactionType };\n\n// We can't import this from `@fuel-ts/script` because it causes\n// cyclic dependency errors so we duplicate it here.\nexport const returnZeroScript: AbstractScriptRequest<void> = {\n  /*\n    Opcode::RET(REG_ZERO)\n    Opcode::NOOP\n  */\n  // TODO: Don't use hardcoded scripts: https://github.com/FuelLabs/fuels-ts/issues/281\n  bytes: arrayify('0x24000000'),\n  encodeScriptData: () => new Uint8Array(0),\n};\n\nexport const withdrawScript: AbstractScriptRequest<void> = {\n  /*\n\t\tThe following code loads some basic values into registers and calls SMO to create an output message\n\n\t\t5040C010 \t- ADDI r16 $is i16   [r16 now points to memory 16 bytes from the start of this program (start of receiver data)]\n\t\t5D44C006\t- LW r17 $is i6      [r17 set to the 6th word in this program (6*8=48 bytes from the start of this program)]\n\t\t4C400011\t- SMO r16 r0 r0 r17  [send message out to address starting at memory position r16 with amount in r17]\n\t\t24000000\t- RET                [return 0]\n\t\t00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 [recipient address]\n\t\t00000000 00000000 [amount value]\n\t*/\n  // TODO: Don't use hardcoded scripts: https://github.com/FuelLabs/fuels-ts/issues/281\n  bytes: arrayify('0x5040C0105D44C0064C40001124000000'),\n  encodeScriptData: () => new Uint8Array(0),\n};\n\ninterface BaseTransactionRequestLike {\n  /** Gas price for transaction */\n  gasPrice?: BigNumberish;\n  /** Gas limit for transaction */\n  gasLimit?: BigNumberish;\n  /** Block until which tx cannot be included */\n  maturity?: number;\n  /** List of inputs */\n  inputs?: TransactionRequestInput[];\n  /** List of outputs */\n  outputs?: TransactionRequestOutput[];\n  /** List of witnesses */\n  witnesses?: TransactionRequestWitness[];\n}\n\nexport class ChangeOutputCollisionError extends Error {\n  name = 'ChangeOutputCollisionError';\n  message = 'A ChangeOutput with the same \"assetId\" already exists for a different \"to\" address';\n}\n\nexport class NoWitnessAtIndexError extends Error {\n  name = 'NoWitnessAtIndexError';\n  constructor(public readonly index: number) {\n    super();\n    this.message = `Witness at index \"${index}\" was not found`;\n  }\n}\n\nexport class NoWitnessByOwnerError extends Error {\n  name = 'NoWitnessByOwnerError';\n  constructor(public readonly owner: AbstractAddress) {\n    super();\n    this.message = `A witness for the given owner \"${owner}\" was not found`;\n  }\n}\n\nabstract class BaseTransactionRequest implements BaseTransactionRequestLike {\n  /** Type of the transaction */\n  abstract type: TransactionType;\n  /** Gas price for transaction */\n  gasPrice: BN;\n  /** Gas limit for transaction */\n  gasLimit: BN;\n  /** Block until which tx cannot be included */\n  maturity: number;\n  /** List of inputs */\n  inputs: TransactionRequestInput[] = [];\n  /** List of outputs */\n  outputs: TransactionRequestOutput[] = [];\n  /** List of witnesses */\n  witnesses: TransactionRequestWitness[] = [];\n\n  constructor({\n    gasPrice,\n    gasLimit,\n    maturity,\n    inputs,\n    outputs,\n    witnesses,\n  }: BaseTransactionRequestLike = {}) {\n    this.gasPrice = bn(gasPrice ?? 0);\n    this.gasLimit = bn(gasLimit ?? 0);\n    this.maturity = maturity ?? 0;\n    this.inputs = [...(inputs ?? [])];\n    this.outputs = [...(outputs ?? [])];\n    this.witnesses = [...(witnesses ?? [])];\n  }\n\n  protected getBaseTransaction(): Pick<\n    TransactionScript | TransactionCreate,\n    keyof BaseTransactionRequestLike | 'inputsCount' | 'outputsCount' | 'witnessesCount'\n  > {\n    const inputs = this.inputs?.map(inputify) ?? [];\n    const outputs = this.outputs?.map(outputify) ?? [];\n    const witnesses = this.witnesses?.map(witnessify) ?? [];\n    return {\n      gasPrice: this.gasPrice,\n      gasLimit: this.gasLimit,\n      maturity: this.maturity,\n      inputs,\n      outputs,\n      witnesses,\n      inputsCount: inputs.length,\n      outputsCount: outputs.length,\n      witnessesCount: witnesses.length,\n    };\n  }\n\n  abstract toTransaction(): TransactionCreate | TransactionScript;\n\n  toTransactionBytes(): Uint8Array {\n    return new TransactionCoder().encode(this.toTransaction());\n  }\n\n  /**\n   * Pushes an input to the list without any side effects and returns the index\n   */\n  protected pushInput(input: TransactionRequestInput): number {\n    this.inputs.push(input);\n    return this.inputs.length - 1;\n  }\n\n  /**\n   * Pushes an output to the list without any side effects and returns the index\n   */\n  protected pushOutput(output: TransactionRequestOutput): number {\n    this.outputs.push(output);\n    return this.outputs.length - 1;\n  }\n\n  /**\n   * Creates an empty witness without any side effects and returns the index\n   */\n  protected createWitness() {\n    this.witnesses.push('0x');\n    return this.witnesses.length - 1;\n  }\n\n  updateWitnessByOwner(address: AbstractAddress, signature: BytesLike) {\n    const witnessIndex = this.getCoinInputWitnessIndexByOwner(address);\n    if (typeof witnessIndex === 'number') {\n      this.updateWitness(witnessIndex, signature);\n    }\n  }\n\n  /**\n   * Updates an existing witness without any side effects\n   */\n  updateWitness(index: number, witness: TransactionRequestWitness) {\n    if (!this.witnesses[index]) {\n      throw new NoWitnessAtIndexError(index);\n    }\n    this.witnesses[index] = witness;\n  }\n\n  getCoinInputs(): CoinTransactionRequestInput[] {\n    return this.inputs.filter(\n      (input): input is CoinTransactionRequestInput => input.type === InputType.Coin\n    );\n  }\n\n  getCoinOutputs(): CoinTransactionRequestOutput[] {\n    return this.outputs.filter(\n      (output): output is CoinTransactionRequestOutput => output.type === OutputType.Coin\n    );\n  }\n\n  getChangeOutputs(): ChangeTransactionRequestOutput[] {\n    return this.outputs.filter(\n      (output): output is ChangeTransactionRequestOutput => output.type === OutputType.Change\n    );\n  }\n\n  /**\n   * Returns the witnessIndex of the found CoinInput\n   */\n  getCoinInputWitnessIndexByOwner(owner: AddressLike): number | null {\n    const ownerAddress = addressify(owner);\n    return (\n      this.inputs.find(\n        (input): input is CoinTransactionRequestInput =>\n          input.type === InputType.Coin && hexlify(input.owner) === ownerAddress.toB256()\n      )?.witnessIndex ??\n      this.inputs.find(\n        (input): input is MessageTransactionRequestInput =>\n          input.type === InputType.Message && hexlify(input.recipient) === ownerAddress.toB256()\n      )?.witnessIndex ??\n      null\n    );\n  }\n\n  /**\n   * Updates the witness for the given CoinInput owner\n   */\n  updateWitnessByCoinInputOwner(owner: AddressLike, witness: BytesLike) {\n    const witnessIndex = this.getCoinInputWitnessIndexByOwner(owner);\n\n    if (!witnessIndex) {\n      throw new NoWitnessByOwnerError(addressify(owner));\n    }\n\n    this.updateWitness(witnessIndex, witness);\n  }\n\n  /**\n   * Converts the given Resource to a ResourceInput with the appropriate witnessIndex and pushes it\n   */\n  addResource(resource: Resource) {\n    const ownerAddress = isCoin(resource) ? resource.owner : resource.recipient;\n    const assetId = isCoin(resource) ? resource.assetId : NativeAssetId;\n    const type = isCoin(resource) ? InputType.Coin : InputType.Message;\n    let witnessIndex = this.getCoinInputWitnessIndexByOwner(ownerAddress);\n\n    // Insert a dummy witness if no witness exists\n    if (typeof witnessIndex !== 'number') {\n      witnessIndex = this.createWitness();\n    }\n\n    // Insert the Input\n    this.pushInput(\n      isCoin(resource)\n        ? ({\n            type,\n            ...resource,\n            owner: resource.owner.toB256(),\n            witnessIndex,\n            txPointer: '0x00000000000000000000000000000000',\n          } as CoinTransactionRequestInput)\n        : ({\n            type,\n            ...resource,\n            sender: resource.sender.toB256(),\n            recipient: resource.recipient.toB256(),\n            witnessIndex,\n            txPointer: '0x00000000000000000000000000000000',\n          } as MessageTransactionRequestInput)\n    );\n\n    // Find the ChangeOutput for the AssetId of the Resource\n    const changeOutput = this.getChangeOutputs().find(\n      (output) => hexlify(output.assetId) === assetId\n    );\n\n    // Throw if the existing ChangeOutput is not for the same owner\n    if (changeOutput && hexlify(changeOutput.to) !== ownerAddress.toB256()) {\n      throw new ChangeOutputCollisionError();\n    }\n\n    // Insert a ChangeOutput if it does not exist\n    if (!changeOutput) {\n      this.pushOutput({\n        type: OutputType.Change,\n        to: ownerAddress.toB256(),\n        assetId,\n      });\n    }\n  }\n\n  addResources(resources: ReadonlyArray<Resource>) {\n    resources.forEach((resource) => this.addResource(resource));\n  }\n\n  addCoinOutput(\n    /** Address of the destination */\n    to: AddressLike,\n    /** Amount of coins */\n    amount: BigNumberish,\n    /** Asset ID of coins */\n    assetId: BytesLike = NativeAssetId\n  ) {\n    this.pushOutput({\n      type: OutputType.Coin,\n      to: addressify(to).toB256(),\n      amount,\n      assetId,\n    });\n  }\n\n  addCoinOutputs(\n    /** Address of the destination */\n    to: AddressLike,\n    /** Quantities of coins */\n    quantities: CoinQuantityLike[]\n  ) {\n    quantities.map(coinQuantityfy).forEach((quantity) => {\n      this.pushOutput({\n        type: OutputType.Coin,\n        to: addressify(to).toB256(),\n        amount: quantity.amount,\n        assetId: quantity.assetId,\n      });\n    });\n  }\n\n  byteSize() {\n    return this.toTransactionBytes().length;\n  }\n\n  chargeableByteSize() {\n    const witnessSize = this.witnesses.reduce((total, w) => total + arrayify(w).length, 0);\n    return bn(this.toTransactionBytes().length - witnessSize);\n  }\n\n  /**\n   * Return the minimum amount in native coins required to create\n   * a transaction.\n   *\n   * Note: this is required even gasPrice = 0\n   */\n  calculateFee(): CoinQuantity {\n    const gasFee = calculatePriceWithFactor(this.gasLimit, this.gasPrice, GAS_PRICE_FACTOR);\n\n    return {\n      assetId: NativeAssetId,\n      amount: gasFee.isZero() ? bn(1) : gasFee,\n    };\n  }\n\n  toJSON() {\n    return normalizeJSON(this);\n  }\n}\n\nexport interface ScriptTransactionRequestLike extends BaseTransactionRequestLike {\n  /** Script to execute */\n  script?: BytesLike;\n  /** Script input data (parameters) */\n  scriptData?: BytesLike;\n}\n\nexport class ScriptTransactionRequest extends BaseTransactionRequest {\n  static from(obj: ScriptTransactionRequestLike) {\n    if (obj instanceof this) {\n      return obj;\n    }\n    return new this(obj);\n  }\n\n  /** Type of the transaction */\n  type = TransactionType.Script as const;\n  /** Script to execute */\n  script: Uint8Array;\n  /** Script input data (parameters) */\n  scriptData: Uint8Array;\n  /** determined bytes offset for start of script data */\n  bytesOffset: number | undefined;\n\n  constructor({ script, scriptData, ...rest }: ScriptTransactionRequestLike = {}) {\n    super(rest);\n    this.script = arrayify(script ?? returnZeroScript.bytes);\n    this.scriptData = arrayify(scriptData ?? returnZeroScript.encodeScriptData());\n  }\n\n  toTransaction(): TransactionScript {\n    const script = arrayify(this.script ?? '0x');\n    const scriptData = arrayify(this.scriptData ?? '0x');\n    return {\n      type: TransactionType.Script,\n      ...super.getBaseTransaction(),\n      scriptLength: script.length,\n      scriptDataLength: scriptData.length,\n      receiptsRoot: ZeroBytes32,\n      script: hexlify(script),\n      scriptData: hexlify(scriptData),\n    };\n  }\n\n  getContractInputs(): ContractTransactionRequestInput[] {\n    return this.inputs.filter(\n      (input): input is ContractTransactionRequestInput => input.type === InputType.Contract\n    );\n  }\n\n  getContractOutputs(): ContractTransactionRequestOutput[] {\n    return this.outputs.filter(\n      (output): output is ContractTransactionRequestOutput => output.type === OutputType.Contract\n    );\n  }\n\n  getVariableOutputs(): VariableTransactionRequestOutput[] {\n    return this.outputs.filter(\n      (output): output is VariableTransactionRequestOutput => output.type === OutputType.Variable\n    );\n  }\n\n  setScript<T>(script: AbstractScriptRequest<T>, data: T) {\n    this.script = script.bytes;\n    this.scriptData = script.encodeScriptData(data);\n\n    if (this.bytesOffset === undefined) {\n      this.bytesOffset = this.scriptData.byteLength;\n    }\n  }\n\n  addVariableOutputs(numberOfVariables: number = 1) {\n    let outputsNumber = numberOfVariables;\n\n    while (outputsNumber) {\n      this.pushOutput({\n        type: OutputType.Variable,\n      });\n      outputsNumber -= 1;\n    }\n\n    return this.outputs.length - 1;\n  }\n\n  addMessageOutputs(numberOfMessages: number = 1) {\n    let outputsNumber = numberOfMessages;\n\n    while (outputsNumber) {\n      this.pushOutput({\n        type: OutputType.Message,\n        recipient: '0x0000000000000000000000000000000000000000000000000000000000000000',\n        amount: 0,\n      });\n      outputsNumber -= 1;\n    }\n\n    return this.outputs.length - 1;\n  }\n\n  addContract(contract: ContractIdLike) {\n    const contractAddress = addressify(contract);\n\n    // Add only one input contract per contractId\n    if (this.getContractInputs().find((i) => i.contractId === contractAddress.toB256())) {\n      return;\n    }\n\n    const inputIndex = super.pushInput({\n      type: InputType.Contract,\n      contractId: contractAddress.toB256(),\n      txPointer: '0x00000000000000000000000000000000',\n    });\n\n    this.pushOutput({\n      type: OutputType.Contract,\n      inputIndex,\n    });\n  }\n}\n\nexport interface CreateTransactionRequestLike extends BaseTransactionRequestLike {\n  /** Witness index of contract bytecode to create */\n  bytecodeWitnessIndex?: number;\n  /** Salt */\n  salt?: BytesLike;\n  /** List of storage slots to initialize */\n  storageSlots?: TransactionRequestStorageSlot[];\n}\n\nexport class CreateTransactionRequest extends BaseTransactionRequest {\n  static from(obj: CreateTransactionRequestLike) {\n    if (obj instanceof this) {\n      return obj;\n    }\n    return new this(obj);\n  }\n\n  /** Type of the transaction */\n  type = TransactionType.Create as const;\n  /** Witness index of contract bytecode to create */\n  bytecodeWitnessIndex: number;\n  /** Salt */\n  salt: string;\n  /** List of storage slots to initialize */\n  storageSlots: TransactionRequestStorageSlot[];\n\n  constructor({\n    bytecodeWitnessIndex,\n    salt,\n    storageSlots,\n    ...rest\n  }: CreateTransactionRequestLike = {}) {\n    super(rest);\n    this.bytecodeWitnessIndex = bytecodeWitnessIndex ?? 0;\n    this.salt = hexlify(salt ?? ZeroBytes32);\n    this.storageSlots = [...(storageSlots ?? [])];\n  }\n\n  toTransaction(): TransactionCreate {\n    const baseTransaction = this.getBaseTransaction();\n    const bytecodeWitnessIndex = this.bytecodeWitnessIndex;\n    const storageSlots = this.storageSlots?.map(storageSlotify) ?? [];\n    return {\n      type: TransactionType.Create,\n      ...baseTransaction,\n      bytecodeLength: baseTransaction.witnesses[bytecodeWitnessIndex].dataLength / 4,\n      bytecodeWitnessIndex,\n      storageSlotsCount: storageSlots.length,\n      salt: this.salt ? hexlify(this.salt) : ZeroBytes32,\n      storageSlots,\n    };\n  }\n\n  getContractCreatedOutputs(): ContractCreatedTransactionRequestOutput[] {\n    return this.outputs.filter(\n      (output): output is ContractCreatedTransactionRequestOutput =>\n        output.type === OutputType.ContractCreated\n    );\n  }\n\n  addContractCreatedOutput(\n    /** Contract ID */\n    contractId: BytesLike,\n    /** State Root */\n    stateRoot: BytesLike\n  ) {\n    this.pushOutput({\n      type: OutputType.ContractCreated,\n      contractId,\n      stateRoot,\n    });\n  }\n}\n\nexport type TransactionRequest = ScriptTransactionRequest | CreateTransactionRequest;\nexport type TransactionRequestLike =\n  | ({ type: TransactionType.Script } & ScriptTransactionRequestLike)\n  | ({ type: TransactionType.Create } & CreateTransactionRequestLike);\n\nexport const transactionRequestify = (obj: TransactionRequestLike): TransactionRequest => {\n  if (obj instanceof ScriptTransactionRequest || obj instanceof CreateTransactionRequest) {\n    return obj;\n  }\n  switch (obj.type) {\n    case TransactionType.Script: {\n      return ScriptTransactionRequest.from(obj);\n    }\n    case TransactionType.Create: {\n      return CreateTransactionRequest.from(obj);\n    }\n    default: {\n      throw new Error(\n        `Unknown transaction type: ${\n          // @ts-expect-error Unreachable code\n          obj.type\n        }`\n      );\n    }\n  }\n};\n","import type { ReceiptPanic, ReceiptRevert } from '@fuel-ts/transactions';\nimport { ReceiptType } from '@fuel-ts/transactions';\nimport { FAILED_TRANSFER_TO_ADDRESS_SIGNAL } from '@fuel-ts/transactions/configs';\n\nimport type { TransactionResultReceipt } from '../transaction-response';\n\nconst doesReceiptHaveMissingOutputVariables = (\n  receipt: TransactionResultReceipt\n): receipt is ReceiptRevert =>\n  receipt.type === ReceiptType.Revert &&\n  receipt.val.toString('hex') === FAILED_TRANSFER_TO_ADDRESS_SIGNAL;\n\nconst doesReceiptHaveMissingContractId = (\n  receipt: TransactionResultReceipt\n): receipt is ReceiptPanic =>\n  receipt.type === ReceiptType.Panic &&\n  receipt.contractId !== '0x0000000000000000000000000000000000000000000000000000000000000000';\n\nexport const getReceiptsWithMissingData = (receipts: Array<TransactionResultReceipt>) =>\n  receipts.reduce<{\n    missingOutputVariables: Array<ReceiptRevert>;\n    missingOutputContractIds: Array<ReceiptPanic>;\n  }>(\n    (memo, receipt) => {\n      if (doesReceiptHaveMissingOutputVariables(receipt)) {\n        memo.missingOutputVariables.push(receipt);\n      }\n      if (doesReceiptHaveMissingContractId(receipt)) {\n        memo.missingOutputContractIds.push(receipt);\n      }\n      return memo;\n    },\n    {\n      missingOutputVariables: [],\n      missingOutputContractIds: [],\n    }\n  );\n","import type { BN } from '@fuel-ts/math';\nimport { bn, multiply } from '@fuel-ts/math';\nimport { ReceiptType } from '@fuel-ts/transactions';\nimport { GAS_PRICE_FACTOR } from '@fuel-ts/transactions/configs';\n\nimport type { TransactionResultReceipt } from '../transaction-response';\n\nexport const calculatePriceWithFactor = (gasUsed: BN, gasPrice: BN, priceFactor: BN): BN =>\n  bn(Math.ceil(gasUsed.toNumber() / priceFactor.toNumber()) * gasPrice.toNumber());\n\nexport const getGasUsedFromReceipts = (receipts: Array<TransactionResultReceipt>): BN => {\n  const scriptResult = receipts.find((receipt) => receipt.type === ReceiptType.ScriptResult);\n\n  if (scriptResult && scriptResult.type === ReceiptType.ScriptResult) {\n    return scriptResult.gasUsed;\n  }\n\n  return bn(0);\n};\n\nexport const calculateTransactionFee = ({\n  receipts,\n  gasPrice,\n  margin,\n}: {\n  receipts: TransactionResultReceipt[];\n  gasPrice: BN;\n  margin?: number;\n}) => {\n  const gasUsed = multiply(getGasUsedFromReceipts(receipts), margin || 1);\n  const fee = calculatePriceWithFactor(gasUsed, gasPrice, GAS_PRICE_FACTOR);\n\n  return {\n    gasUsed,\n    fee,\n  };\n};\n","const DEFAULT_BLOCK_EXPLORER_URL = 'https://fuellabs.github.io/block-explorer-v2';\n\nconst getPathFromInput = (\n  key: BuildBlockExplorerUrlHelperParam,\n  value: string | number | undefined\n) => {\n  const pathMap = {\n    address: `address`,\n    txId: `transaction`,\n    blockNumber: `block`,\n  };\n  const path = pathMap[key] || key;\n  return `${path}/${value}`;\n};\n\ntype BuildBlockExplorerUrlHelperParam = 'address' | 'txId' | 'blockNumber';\n\n/**\n * Builds a block explorer url based on and the given path, block explorer URL and provider URL\n */\nexport const buildBlockExplorerUrl = (\n  options: {\n    blockExplorerUrl?: string;\n    path?: string;\n    providerUrl?: string;\n    address?: string;\n    txId?: string;\n    blockNumber?: number;\n  } = {}\n) => {\n  const { blockExplorerUrl, path, providerUrl, address, txId, blockNumber } = options;\n  const explorerUrl = blockExplorerUrl || DEFAULT_BLOCK_EXPLORER_URL;\n\n  // make sure that only ONE or none of the following is defined: address, txId, blockNumber\n  const customInputParams = [\n    {\n      key: 'address',\n      value: address,\n    },\n    {\n      key: 'txId',\n      value: txId,\n    },\n    {\n      key: 'blockNumber',\n      value: blockNumber,\n    },\n  ];\n\n  const definedValues = customInputParams\n    .filter((param) => !!param.value)\n    .map(({ key, value }) => ({\n      key,\n      value,\n    }));\n\n  const hasAnyDefinedValues = definedValues.length > 0;\n\n  if (definedValues.length > 1) {\n    throw new Error(\n      `Only one of the following can be passed in to buildBlockExplorerUrl: ${customInputParams\n        .map((param) => param.key)\n        .join(', ')}`\n    );\n  }\n\n  if (path && definedValues.length > 0) {\n    const inputKeys = customInputParams.map(({ key }) => key).join(', ');\n    throw new Error(\n      `You cannot pass in a path to buildBlockExplorerUrl along with any of the following: ${inputKeys}`\n    );\n  }\n\n  const pathGeneratedFromInputParams = hasAnyDefinedValues\n    ? getPathFromInput(\n        definedValues[0].key as BuildBlockExplorerUrlHelperParam,\n        definedValues[0].value\n      )\n    : '';\n\n  // Remove leading and trailing slashes from the path and block explorer url respectively, if present\n  const trimSlashes = /^\\/|\\/$/gm;\n  const cleanPath = path ? path.replace(trimSlashes, '') : pathGeneratedFromInputParams;\n  const cleanBlockExplorerUrl = explorerUrl.replace(trimSlashes, '');\n  const cleanProviderUrl = providerUrl?.replace(trimSlashes, '');\n  const encodedProviderUrl = cleanProviderUrl ? encodeURIComponent(cleanProviderUrl) : undefined;\n\n  // if the block explorer url doesn't have a protocol i.e. http:// or https://, add https://\n  const protocol = cleanBlockExplorerUrl.match(/^https?:\\/\\//) ? '' : 'https://';\n  const providerUrlProtocol = cleanProviderUrl?.match(/^https?:\\/\\//) ? '' : 'https://';\n\n  const url = `${protocol}${cleanBlockExplorerUrl}/${cleanPath}${\n    encodedProviderUrl ? `?providerUrl=${providerUrlProtocol}${encodedProviderUrl}` : ''\n  }`;\n\n  return url;\n};\n","/* eslint-disable no-param-reassign */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { hexlify } from '@ethersproject/bytes';\nimport cloneDeep from 'lodash.clonedeep';\n\n// When parsing a Transaction to JSON we need\n// to convert special types into each respective\n// JSON friendly value. This enables a tx to be\n// stringified and parsed back into a Transaction\nfunction normalize(object: any) {\n  Object.keys(object).forEach((key) => {\n    switch (object[key].constructor.name) {\n      case 'Uint8Array':\n        object[key] = hexlify(object[key]);\n        break;\n      case 'Array':\n        object[key] = normalize(object[key]);\n        break;\n      case 'BN':\n        object[key] = object[key].toHex();\n        break;\n      case 'Address':\n        object[key] = object[key].toB256();\n        break;\n      case 'Object':\n        object[key] = normalize(object[key]);\n        break;\n      default:\n        break;\n    }\n  });\n  return object;\n}\n\n/**\n * Stringify Transaction to a JSON object\n * compatible with the Transaction class constructor.\n */\nexport function normalizeJSON(root: any) {\n  // Do a single deep clone before normalizing\n  // to avoid mutating the original object\n  // and doing extra clones on each iteration\n  return normalize(cloneDeep(root));\n}\n","export function sleep(time: number) {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(true);\n    }, time);\n  });\n}\n","import type { BytesLike } from '@ethersproject/bytes';\nimport { hexlify, arrayify } from '@ethersproject/bytes';\nimport type { StorageSlot } from '@fuel-ts/transactions';\n\nexport type TransactionRequestStorageSlot =\n  | {\n      /** Key */\n      key: BytesLike;\n      /** Value */\n      value: BytesLike;\n    }\n  | [key: BytesLike, value: BytesLike];\n\n// Make sure all values have 32 bytes\nconst getStorageValue = (value: BytesLike): Uint8Array => {\n  const v = new Uint8Array(32);\n  v.set(arrayify(value));\n  return v;\n};\n\nexport const storageSlotify = (storageSlot: TransactionRequestStorageSlot): StorageSlot => {\n  let key;\n  let value;\n\n  if (Array.isArray(storageSlot)) {\n    key = storageSlot[0];\n    value = storageSlot[1];\n  } else {\n    key = storageSlot.key;\n    value = storageSlot.value;\n  }\n\n  return {\n    key: hexlify(key),\n    value: hexlify(getStorageValue(value)),\n  };\n};\n","import type { BytesLike } from '@ethersproject/bytes';\nimport { arrayify, hexlify } from '@ethersproject/bytes';\nimport type { Witness } from '@fuel-ts/transactions';\n\nexport type TransactionRequestWitness = BytesLike;\n\nexport const witnessify = (value: TransactionRequestWitness): Witness => {\n  const data = arrayify(value);\n\n  return {\n    data: hexlify(data),\n    dataLength: data.length,\n  };\n};\n","/* eslint-disable @typescript-eslint/no-non-null-assertion */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { arrayify } from '@ethersproject/bytes';\nimport type { BN } from '@fuel-ts/math';\nimport { bn } from '@fuel-ts/math';\nimport type {\n  ReceiptCall,\n  ReceiptLog,\n  ReceiptLogData,\n  ReceiptPanic,\n  ReceiptReturn,\n  ReceiptReturnData,\n  ReceiptRevert,\n  ReceiptTransfer,\n  ReceiptTransferOut,\n  ReceiptScriptResult,\n  ReceiptMessageOut,\n  Transaction,\n} from '@fuel-ts/transactions';\nimport { TransactionCoder, ReceiptType, ReceiptCoder } from '@fuel-ts/transactions';\n\nimport type {\n  GqlGetTransactionWithReceiptsQuery,\n  GqlReceiptFragmentFragment,\n} from '../__generated__/operations';\nimport type Provider from '../provider';\nimport { calculateTransactionFee, sleep } from '../utils';\n\nexport type TransactionResultCallReceipt = ReceiptCall;\nexport type TransactionResultReturnReceipt = ReceiptReturn;\nexport type TransactionResultReturnDataReceipt = ReceiptReturnData & { data: string };\nexport type TransactionResultPanicReceipt = ReceiptPanic;\nexport type TransactionResultRevertReceipt = ReceiptRevert;\nexport type TransactionResultLogReceipt = ReceiptLog;\nexport type TransactionResultLogDataReceipt = ReceiptLogData & { data: string };\nexport type TransactionResultTransferReceipt = ReceiptTransfer;\nexport type TransactionResultTransferOutReceipt = ReceiptTransferOut;\nexport type TransactionResultScriptResultReceipt = ReceiptScriptResult;\nexport type TransactionResultMessageOutReceipt = ReceiptMessageOut;\n\nexport type TransactionResultReceipt =\n  | TransactionResultCallReceipt\n  | TransactionResultReturnReceipt\n  | TransactionResultReturnDataReceipt\n  | TransactionResultPanicReceipt\n  | TransactionResultRevertReceipt\n  | TransactionResultLogReceipt\n  | TransactionResultLogDataReceipt\n  | TransactionResultTransferReceipt\n  | TransactionResultTransferOutReceipt\n  | TransactionResultScriptResultReceipt\n  | TransactionResultMessageOutReceipt;\n\nexport type TransactionResult<TStatus extends 'success' | 'failure', TTransactionType = void> = {\n  status: TStatus extends 'success'\n    ? { type: 'success'; programState: any }\n    : { type: 'failure'; reason: any };\n  /** Receipts produced during the execution of the transaction */\n  receipts: TransactionResultReceipt[];\n  transactionId: string;\n  blockId: any;\n  time: any;\n  gasUsed: BN;\n  fee: BN;\n  transaction: Transaction<TTransactionType>;\n};\n\nconst STATUS_POLLING_INTERVAL_MAX_MS = 5000;\nconst STATUS_POLLING_INTERVAL_MIN_MS = 1000;\n\nconst processGqlReceipt = (gqlReceipt: GqlReceiptFragmentFragment): TransactionResultReceipt => {\n  const receipt = new ReceiptCoder().decode(arrayify(gqlReceipt.rawPayload), 0)[0];\n\n  switch (receipt.type) {\n    case ReceiptType.ReturnData: {\n      return {\n        ...receipt,\n        data: gqlReceipt.data!,\n      };\n    }\n    case ReceiptType.LogData: {\n      return {\n        ...receipt,\n        data: gqlReceipt.data!,\n      };\n    }\n    default:\n      return receipt;\n  }\n};\n\nexport class TransactionResponse {\n  /** Transaction ID */\n  id: string;\n  /** Current provider */\n  provider: Provider;\n  /** Gas used on the transaction */\n  gasUsed: BN = bn(0);\n  /** Number off attempts to get the committed tx */\n  attempts: number = 0;\n\n  constructor(id: string, provider: Provider) {\n    this.id = id;\n    this.provider = provider;\n  }\n\n  async fetch(): Promise<GqlGetTransactionWithReceiptsQuery['transaction']> {\n    const { transaction } = await this.provider.operations.getTransactionWithReceipts({\n      transactionId: this.id,\n    });\n    return transaction;\n  }\n\n  decodeTransaction<TTransactionType = void>(\n    transactionWithReceipts: NonNullable<GqlGetTransactionWithReceiptsQuery['transaction']>\n  ) {\n    return new TransactionCoder().decode(\n      arrayify(transactionWithReceipts.rawPayload),\n      0\n    )?.[0] as Transaction<TTransactionType>;\n  }\n\n  /** Waits for transaction to succeed or fail and returns the result */\n  async waitForResult<TTransactionType = void>(): Promise<\n    TransactionResult<any, TTransactionType>\n  > {\n    const transactionWithReceipts = await this.fetch();\n\n    switch (transactionWithReceipts?.status?.type) {\n      case undefined:\n      case 'SubmittedStatus': {\n        // This code implements a similar approach from the fuel-core await_transaction_commit\n        // https://github.com/FuelLabs/fuel-core/blob/cb37f9ce9a81e033bde0dc43f91494bc3974fb1b/fuel-client/src/client.rs#L356\n        // double the interval duration on each attempt until max is reached\n        //\n        // This can wait forever, it would be great to implement a max timeout here, but it would require\n        // improve request handler as response Error not mean that the tx fail.\n        this.attempts += 1;\n        await sleep(\n          Math.min(STATUS_POLLING_INTERVAL_MIN_MS * this.attempts, STATUS_POLLING_INTERVAL_MAX_MS)\n        );\n        return this.waitForResult();\n      }\n      case 'FailureStatus': {\n        const receipts = transactionWithReceipts.receipts!.map(processGqlReceipt);\n        const { gasUsed, fee } = calculateTransactionFee({\n          receipts,\n          gasPrice: bn(transactionWithReceipts?.gasPrice),\n        });\n\n        this.gasUsed = gasUsed;\n        return {\n          status: { type: 'failure', reason: transactionWithReceipts.status.reason },\n          receipts,\n          transactionId: this.id,\n          blockId: transactionWithReceipts.status.block.id,\n          time: transactionWithReceipts.status.time,\n          gasUsed,\n          fee,\n          transaction: this.decodeTransaction(transactionWithReceipts),\n        };\n      }\n      case 'SuccessStatus': {\n        const receipts = transactionWithReceipts.receipts?.map(processGqlReceipt) || [];\n        const { gasUsed, fee } = calculateTransactionFee({\n          receipts,\n          gasPrice: bn(transactionWithReceipts?.gasPrice),\n        });\n\n        return {\n          status: { type: 'success', programState: transactionWithReceipts.status.programState },\n          receipts,\n          transactionId: this.id,\n          blockId: transactionWithReceipts.status.block.id,\n          time: transactionWithReceipts.status.time,\n          gasUsed,\n          fee,\n          transaction: this.decodeTransaction(transactionWithReceipts),\n        };\n      }\n      default: {\n        throw new Error('Invalid Transaction status');\n      }\n    }\n  }\n\n  /** Waits for transaction to succeed and returns the result */\n  async wait<TTransactionType = void>(): Promise<TransactionResult<'success', TTransactionType>> {\n    const result = await this.waitForResult<TTransactionType>();\n\n    if (result.status.type === 'failure') {\n      throw new Error(`Transaction failed: ${result.status.reason}`);\n    }\n\n    return result;\n  }\n}\n","import type { Interface } from '@fuel-ts/abi-coder';\nimport { U64Coder } from '@fuel-ts/abi-coder';\nimport { ReceiptType } from '@fuel-ts/transactions';\n\nimport type { TransactionResultReceipt } from './transaction-response';\n\nexport function getDecodedLogs<T = unknown>(\n  receipts: Array<TransactionResultReceipt>,\n  abiInterface: Interface\n): T[] {\n  return receipts.reduce((logs, r) => {\n    if (r.type === ReceiptType.LogData) {\n      return logs.concat(...abiInterface.decodeLog(r.data, r.val1.toNumber(), r.id));\n    }\n\n    if (r.type === ReceiptType.Log) {\n      return logs.concat(\n        ...abiInterface.decodeLog(new U64Coder().encode(r.val0), r.val1.toNumber(), r.id)\n      );\n    }\n\n    return logs;\n  }, []);\n}\n"],"mappings":"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","names":["src_exports","__export","ChangeOutputCollisionError","GqlCoinStatus","CreateTransactionRequest","GqlMessageStatus","NoWitnessAtIndexError","NoWitnessByOwnerError","Provider","ScriptTransactionRequest","TransactionResponse","buildBlockExplorerUrl","calculatePriceWithFactor","calculateTransactionFee","coinQuantityfy","getDecodedLogs","getGasUsedFromReceipts","getReceiptsWithMissingData","inputify","isCoin","isMessage","isRawCoin","isRawMessage","normalizeJSON","outputify","returnZeroScript","sleep","transactionRequestify","withdrawScript","__toCommonJS","import_bytes","import_configs","import_math","coinQuantityfy","coinQuantityLike","_a","_b","_c","_d","assetId","amount","max","import_graphql_tag","GqlCoinStatus","GqlMessageStatus","TransactionFragmentFragmentDoc","gql","ReceiptFragmentFragmentDoc","CoinFragmentFragmentDoc","MessageFragmentFragmentDoc","MessageProofFragmentFragmentDoc","BalanceFragmentFragmentDoc","ConsensusParametersFragmentFragmentDoc","BlockFragmentFragmentDoc","ChainInfoFragmentFragmentDoc","ContractBalanceFragmentFragmentDoc","GetVersionDocument","GetInfoDocument","GetChainDocument","GetTransactionDocument","GetTransactionWithReceiptsDocument","GetTransactionsDocument","GetTransactionsByOwnerDocument","GetBlockDocument","GetBlockWithTransactionsDocument","GetBlocksDocument","GetCoinDocument","GetCoinsDocument","GetResourcesToSpendDocument","GetContractDocument","GetContractBalanceDocument","GetBalanceDocument","GetBalancesDocument","GetMessagesDocument","GetMessageProofDocument","DryRunDocument","SubmitDocument","StartSessionDocument","EndSessionDocument","ExecuteDocument","ResetDocument","defaultWrapper","action","_operationName","_operationType","getSdk","client","withWrapper","variables","requestHeaders","wrappedRequestHeaders","import_bytes","import_address","import_math","import_transactions","import_configs","import_graphql_request","import_lodash","isRawCoin","resource","isRawMessage","isCoin","isMessage","import_bytes","import_configs","import_math","import_transactions","inputify","value","_a","_b","_c","_d","_e","predicate","predicateData","import_bytes","import_configs","import_math","import_transactions","outputify","value","import_bytes","import_address","import_configs","import_math","import_transactions","import_transactions","import_configs","doesReceiptHaveMissingOutputVariables","receipt","doesReceiptHaveMissingContractId","getReceiptsWithMissingData","receipts","memo","import_math","import_transactions","import_configs","calculatePriceWithFactor","gasUsed","gasPrice","priceFactor","getGasUsedFromReceipts","receipts","scriptResult","receipt","calculateTransactionFee","margin","fee","DEFAULT_BLOCK_EXPLORER_URL","getPathFromInput","key","value","buildBlockExplorerUrl","options","blockExplorerUrl","path","providerUrl","address","txId","blockNumber","explorerUrl","customInputParams","definedValues","param","hasAnyDefinedValues","inputKeys","pathGeneratedFromInputParams","trimSlashes","cleanPath","cleanBlockExplorerUrl","cleanProviderUrl","encodedProviderUrl","protocol","providerUrlProtocol","import_bytes","import_lodash","normalize","object","key","normalizeJSON","root","cloneDeep","sleep","time","resolve","import_bytes","getStorageValue","value","v","storageSlotify","storageSlot","key","import_bytes","witnessify","value","data","returnZeroScript","withdrawScript","ChangeOutputCollisionError","NoWitnessAtIndexError","index","NoWitnessByOwnerError","owner","BaseTransactionRequest","gasPrice","gasLimit","maturity","inputs","outputs","witnesses","_a","_b","_c","_d","_e","_f","inputify","outputify","witnessify","input","output","address","signature","witnessIndex","witness","ownerAddress","resource","isCoin","assetId","type","changeOutput","resources","to","amount","quantities","coinQuantityfy","quantity","witnessSize","total","w","gasFee","calculatePriceWithFactor","normalizeJSON","ScriptTransactionRequest","obj","script","scriptData","rest","data","numberOfVariables","outputsNumber","numberOfMessages","contract","contractAddress","i","inputIndex","CreateTransactionRequest","bytecodeWitnessIndex","salt","storageSlots","baseTransaction","storageSlotify","contractId","stateRoot","transactionRequestify","import_bytes","import_math","import_transactions","STATUS_POLLING_INTERVAL_MAX_MS","STATUS_POLLING_INTERVAL_MIN_MS","processGqlReceipt","gqlReceipt","receipt","TransactionResponse","id","provider","transaction","transactionWithReceipts","_a","_b","sleep","receipts","gasUsed","fee","calculateTransactionFee","result","MAX_RETRIES","processGqlReceipt","gqlReceipt","receipt","processGqlChain","chain","name","baseChainHeight","peerCount","consensusParameters","latestBlock","processNodeInfo","nodeInfo","Provider","url","options","gqlClient","getSdk","nodeVersion","transactionRequestLike","transactionRequest","transactionRequestify","encodedTransaction","gasUsed","minGasPrice","transactionId","TransactionResponse","utxoValidation","gqlReceipts","missingOutputVariableCount","missingOutputContractIdsCount","tries","receipts","missingOutputVariables","missingOutputContractIds","getReceiptsWithMissingData","contractId","tolerance","cloneDeep","gasPrice","margin","fee","calculateTransactionFee","owner","assetId","paginationArgs","edge","coin","quantities","excludedIds","_a","_b","excludeInput","id","coinQuantityfy","amount","maxPerAsset","resource","isRawCoin","idOrHeight","variables","block","tx","transaction","contract","contractBalance","balance","address","message","messageId","result","import_abi_coder","import_transactions","getDecodedLogs","receipts","abiInterface","logs","r"]}