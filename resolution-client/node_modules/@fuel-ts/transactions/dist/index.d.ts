import { BytesLike } from '@ethersproject/bytes';
import { StructCoder, NumberCoder, B256Coder, Coder } from '@fuel-ts/abi-coder';
import { BN } from '@fuel-ts/math';

type TxPointer = {
    /** Block height (u32) */
    blockHeight: number;
    /** Transaction index (u16) */
    txIndex: number;
};
declare class TxPointerCoder extends StructCoder<{
    blockHeight: NumberCoder;
    txIndex: NumberCoder;
}> {
    constructor();
}

type UtxoId = {
    /** Transaction ID (b256) */
    transactionId: string;
    /** Output index (u8) */
    outputIndex: number;
};
declare class UtxoIdCoder extends StructCoder<{
    transactionId: B256Coder;
    outputIndex: NumberCoder;
}> {
    constructor();
}

declare enum InputType {
    Coin = 0,
    Contract = 1,
    Message = 2
}
type InputCoin = {
    type: InputType.Coin;
    /** UTXO ID (UtxoId) */
    utxoID: UtxoId;
    /** Owning address or script hash (b256) */
    owner: string;
    /** Amount of coins (u64) */
    amount: BN;
    /** Asset ID of the coins (b256) */
    assetId: string;
    /** Points to the TX whose output is being spent. (TxPointer) */
    txPointer: TxPointer;
    /** Index of witness that authorizes spending the coin (u8) */
    witnessIndex: number;
    /** UTXO being spent must have been created at least this many blocks ago (u32) */
    maturity: number;
    /** Length of predicate, in instructions (u16) */
    predicateLength: number;
    /** Length of predicate input data, in bytes (u16) */
    predicateDataLength: number;
    /** Predicate bytecode (byte[]) */
    predicate: string;
    /** Predicate input data (parameters) (byte[]) */
    predicateData: string;
};
declare class InputCoinCoder extends Coder<InputCoin, InputCoin> {
    constructor();
    encode(value: InputCoin): Uint8Array;
    decode(data: Uint8Array, offset: number): [InputCoin, number];
}
type InputContract = {
    type: InputType.Contract;
    /** UTXO ID (UtxoId) */
    utxoID: UtxoId;
    /** Root of amount of coins owned by contract before transaction execution (b256) */
    balanceRoot: string;
    /** State root of contract before transaction execution (b256) */
    stateRoot: string;
    /** Points to the TX whose output is being spent. (TxPointer) */
    txPointer: TxPointer;
    /** Contract ID (b256) */
    contractID: string;
};
declare class InputContractCoder extends Coder<InputContract, InputContract> {
    constructor();
    encode(value: InputContract): Uint8Array;
    decode(data: Uint8Array, offset: number): [InputContract, number];
}
type InputMessage = {
    type: InputType.Message;
    /** Amount of coins */
    amount: BN;
    /** Address of sender */
    sender: string;
    /** Address of sender */
    recipient: string;
    /** data of message */
    data: string;
    /** Unique nonce of message */
    nonce: BN;
    /** Index of witness that authorizes message (u8) */
    witnessIndex: number;
    /** Length of predicate, in instructions (u16) */
    dataLength: number;
    /** Length of predicate, in instructions (u16) */
    predicateLength: number;
    /** Length of predicate input data, in bytes (u16) */
    predicateDataLength: number;
    /** Predicate bytecode (byte[]) */
    predicate: string;
    /** Predicate input data (parameters) (byte[]) */
    predicateData: string;
};
declare class InputMessageCoder extends Coder<InputMessage, InputMessage> {
    constructor();
    static getMessageId(value: InputMessage): string;
    encode(value: InputMessage): Uint8Array;
    static decodeData(messageData: BytesLike): Uint8Array;
    decode(data: Uint8Array, offset: number): [InputMessage, number];
}
type Input = InputCoin | InputContract | InputMessage;
declare class InputCoder extends Coder<Input, Input> {
    constructor();
    encode(value: Input): Uint8Array;
    decode(data: Uint8Array, offset: number): [Input, number];
}

declare enum OutputType {
    Coin = 0,
    Contract = 1,
    Message = 2,
    Change = 3,
    Variable = 4,
    ContractCreated = 5
}
type OutputCoin = {
    type: OutputType.Coin;
    /** Receiving address or script hash (b256) */
    to: string;
    /** Amount of coins to send (u64) */
    amount: BN;
    /** Asset ID of coins (b256) */
    assetId: string;
};
declare class OutputCoinCoder extends Coder<OutputCoin, OutputCoin> {
    constructor();
    encode(value: OutputCoin): Uint8Array;
    decode(data: Uint8Array, offset: number): [OutputCoin, number];
}
type OutputContract = {
    type: OutputType.Contract;
    /** Index of input contract (u8) */
    inputIndex: number;
    /** Root of amount of coins owned by contract after transaction execution (b256) */
    balanceRoot: string;
    /** State root of contract after transaction execution (b256) */
    stateRoot: string;
};
declare class OutputContractCoder extends Coder<OutputContract, OutputContract> {
    constructor();
    encode(value: OutputContract): Uint8Array;
    decode(data: Uint8Array, offset: number): [OutputContract, number];
}
type OutputMessage = {
    type: OutputType.Message;
    /** Receiving address (b256) */
    recipient: string;
    /** Amount of coins to send with message (u64) */
    amount: BN;
};
declare class OutputMessageCoder extends Coder<OutputMessage, OutputMessage> {
    constructor();
    encode(value: OutputMessage): Uint8Array;
    decode(data: Uint8Array, offset: number): [OutputMessage, number];
}
type OutputChange = {
    type: OutputType.Change;
    /** Receiving address or script hash (b256) */
    to: string;
    /** Amount of coins to send (u64) */
    amount: BN;
    /** Asset ID of coins (b256) */
    assetId: string;
};
declare class OutputChangeCoder extends Coder<OutputChange, OutputChange> {
    constructor();
    encode(value: OutputChange): Uint8Array;
    decode(data: Uint8Array, offset: number): [OutputChange, number];
}
type OutputVariable = {
    type: OutputType.Variable;
    /** Receiving address or script hash (b256) */
    to: string;
    /** Amount of coins to send (u64) */
    amount: BN;
    /** Asset ID of coins (b256) */
    assetId: string;
};
declare class OutputVariableCoder extends Coder<OutputVariable, OutputVariable> {
    constructor();
    encode(value: OutputVariable): Uint8Array;
    decode(data: Uint8Array, offset: number): [OutputVariable, number];
}
type OutputContractCreated = {
    type: OutputType.ContractCreated;
    /** Contract ID (b256) */
    contractId: string;
    /** State root of contract (b256) */
    stateRoot: string;
};
declare class OutputContractCreatedCoder extends Coder<OutputContractCreated, OutputContractCreated> {
    constructor();
    encode(value: OutputContractCreated): Uint8Array;
    decode(data: Uint8Array, offset: number): [OutputContractCreated, number];
}
type Output = OutputCoin | OutputContract | OutputMessage | OutputChange | OutputVariable | OutputContractCreated;
declare class OutputCoder extends Coder<Output, Output> {
    constructor();
    encode(value: Output): Uint8Array;
    decode(data: Uint8Array, offset: number): [Output, number];
}

declare enum ReceiptType {
    Call = 0,
    Return = 1,
    ReturnData = 2,
    Panic = 3,
    Revert = 4,
    Log = 5,
    LogData = 6,
    Transfer = 7,
    TransferOut = 8,
    ScriptResult = 9,
    MessageOut = 10
}
type ReceiptCall = {
    type: ReceiptType.Call;
    /** Contract ID of current context if in an internal context, zero otherwise (b256) */
    from: string;
    /** Contract ID of called contract (b256) */
    to: string;
    /** Amount of coins to forward, i.e. $rB (u64) */
    amount: BN;
    /** Asset ID of coins to forward, i.e. MEM[$rC, 32] (b256) */
    assetId: string;
    /** Gas to forward, i.e. $rD (u64) */
    gas: BN;
    /** First parameter (u64) */
    param1: BN;
    /** Second parameter (u64) */
    param2: BN;
    /** Value of register $pc (u64) */
    pc: BN;
    /** Value of register $is (u64) */
    is: BN;
};
declare class ReceiptCallCoder extends Coder<ReceiptCall, ReceiptCall> {
    constructor();
    encode(value: ReceiptCall): Uint8Array;
    decode(data: Uint8Array, offset: number): [ReceiptCall, number];
}
type ReceiptReturn = {
    type: ReceiptType.Return;
    /** Contract ID of current context if in an internal context, zero otherwise (b256) */
    id: string;
    /** Value of register $rA (u64) */
    val: BN;
    /** Value of register $pc (u64) */
    pc: BN;
    /** Value of register $is (u64) */
    is: BN;
};
declare class ReceiptReturnCoder extends Coder<ReceiptReturn, ReceiptReturn> {
    constructor();
    encode(value: ReceiptReturn): Uint8Array;
    decode(data: Uint8Array, offset: number): [ReceiptReturn, number];
}
type ReceiptReturnData = {
    type: ReceiptType.ReturnData;
    /** Contract ID of current context if in an internal context, zero otherwise (b256) */
    id: string;
    /** Value of register $rA (u64) */
    ptr: BN;
    /** Value of register $rB (u64) */
    len: BN;
    /** Hash of MEM[$rA, $rB] (b256) */
    digest: string;
    /** Value of register $pc (u64) */
    pc: BN;
    /** Value of register $is (u64) */
    is: BN;
};
declare class ReceiptReturnDataCoder extends Coder<ReceiptReturnData, ReceiptReturnData> {
    constructor();
    encode(value: ReceiptReturnData): Uint8Array;
    decode(data: Uint8Array, offset: number): [ReceiptReturnData, number];
}
type ReceiptPanic = {
    type: ReceiptType.Panic;
    /** Contract ID of current context if in an internal context, zero otherwise (b256) */
    id: string;
    /** Panic reason (u64) */
    reason: BN;
    /** Value of register $pc (u64) */
    pc: BN;
    /** Value of register $is (u64) */
    is: BN;
    /** Value of optional contract ID */
    contractId: string;
};
declare class ReceiptPanicCoder extends Coder<ReceiptPanic, ReceiptPanic> {
    constructor();
    encode(value: ReceiptPanic): Uint8Array;
    decode(data: Uint8Array, offset: number): [ReceiptPanic, number];
}
type ReceiptRevert = {
    type: ReceiptType.Revert;
    /** Contract ID of current context if in an internal context, zero otherwise (b256) */
    id: string;
    /** Value of register $rA (u64) */
    val: BN;
    /** Value of register $pc (u64) */
    pc: BN;
    /** Value of register $is (u64) */
    is: BN;
};
declare class ReceiptRevertCoder extends Coder<ReceiptRevert, ReceiptRevert> {
    constructor();
    encode(value: ReceiptRevert): Uint8Array;
    decode(data: Uint8Array, offset: number): [ReceiptRevert, number];
}
type ReceiptLog = {
    type: ReceiptType.Log;
    /** Contract ID of current context if in an internal context, zero otherwise (b256) */
    id: string;
    /** Value of register $rA (u64) */
    val0: BN;
    /** Value of register $rB (u64) */
    val1: BN;
    /** Value of register $rC (u64) */
    val2: BN;
    /** Value of register $rD (u64) */
    val3: BN;
    /** Value of register $pc (u64) */
    pc: BN;
    /** Value of register $is (u64) */
    is: BN;
};
declare class ReceiptLogCoder extends Coder<ReceiptLog, ReceiptLog> {
    constructor();
    encode(value: ReceiptLog): Uint8Array;
    decode(data: Uint8Array, offset: number): [ReceiptLog, number];
}
type ReceiptLogData = {
    type: ReceiptType.LogData;
    /** Contract ID of current context if in an internal context, zero otherwise (b256) */
    id: string;
    /** Value of register $rA (u64) */
    val0: BN;
    /** Value of register $rB (u64) */
    val1: BN;
    /** Value of register $rC (u64) */
    ptr: BN;
    /** Value of register $rD (u64) */
    len: BN;
    /** Hash of MEM[$rC, $rD] (b256) */
    digest: string;
    /** Value of register $pc (u64) */
    pc: BN;
    /** Value of register $is (u64) */
    is: BN;
};
declare class ReceiptLogDataCoder extends Coder<ReceiptLogData, ReceiptLogData> {
    constructor();
    encode(value: ReceiptLogData): Uint8Array;
    decode(data: Uint8Array, offset: number): [ReceiptLogData, number];
}
type ReceiptTransfer = {
    type: ReceiptType.Transfer;
    /** Contract ID of current context if in an internal context, zero otherwise (b256) */
    from: string;
    /** Contract ID of contract to transfer coins to (b256) */
    to: string;
    /** Amount of coins transferred (u64) */
    amount: BN;
    /** Asset ID of coins transferred (b256) */
    assetId: string;
    /** Value of register $pc (u64) */
    pc: BN;
    /** Value of register $is (u64) */
    is: BN;
};
declare class ReceiptTransferCoder extends Coder<ReceiptTransfer, ReceiptTransfer> {
    constructor();
    encode(value: ReceiptTransfer): Uint8Array;
    decode(data: Uint8Array, offset: number): [ReceiptTransfer, number];
}
type ReceiptTransferOut = {
    type: ReceiptType.TransferOut;
    /** Contract ID of current context if in an internal context, zero otherwise (b256) */
    from: string;
    /** Address to transfer coins to (b256) */
    to: string;
    /** Amount of coins transferred (u64) */
    amount: BN;
    /** Asset ID of coins transferred (b256) */
    assetId: string;
    /** Value of register $pc (u64) */
    pc: BN;
    /** Value of register $is (u64) */
    is: BN;
};
declare class ReceiptTransferOutCoder extends Coder<ReceiptTransferOut, ReceiptTransferOut> {
    constructor();
    encode(value: ReceiptTransferOut): Uint8Array;
    decode(data: Uint8Array, offset: number): [ReceiptTransferOut, number];
}
type ReceiptScriptResult = {
    type: ReceiptType.ScriptResult;
    /** Result variant with embedded `PanicReason` in first 8 bits and `instr` (u64) */
    result: BN;
    /** Gas consumed by the script (u64) */
    gasUsed: BN;
};
declare class ReceiptScriptResultCoder extends Coder<ReceiptScriptResult, ReceiptScriptResult> {
    constructor();
    encode(value: ReceiptScriptResult): Uint8Array;
    decode(data: Uint8Array, offset: number): [ReceiptScriptResult, number];
}
type ReceiptMessageOut = {
    type: ReceiptType.MessageOut;
    /** Hexadecimal string representation of the 256-bit (32-byte) message ID */
    messageID: string;
    /** Hexadecimal string representation of the 256-bit (32-byte) address of the message sender: MEM[$fp, 32] */
    sender: string;
    /** Hexadecimal string representation of the 256-bit (32-byte) address of the message recipient: MEM[$rA, 32] */
    recipient: string;
    /** Hexadecimal string representation of a 64-bit unsigned integer; value of register $rD */
    amount: BN;
    /** Hexadecimal string representation of the 256-bit (32-byte) message nonce */
    nonce: string;
    /** Hexadecimal string representation of 256-bit (32-byte), hash of MEM[$rA + 32, $rB] */
    digest: string;
    /** Hexadecimal string representation of the value of the memory range MEM[$rA + 32, $rB] */
    data: Uint8Array;
};
declare class ReceiptMessageOutCoder extends Coder<ReceiptMessageOut, ReceiptMessageOut> {
    constructor();
    encode(value: ReceiptMessageOut): Uint8Array;
    decode(data: Uint8Array, offset: number): [ReceiptMessageOut, number];
}
type Receipt = ReceiptCall | ReceiptReturn | ReceiptReturnData | ReceiptPanic | ReceiptRevert | ReceiptLog | ReceiptLogData | ReceiptTransfer | ReceiptTransferOut | ReceiptScriptResult | ReceiptMessageOut;
declare class ReceiptCoder extends Coder<Receipt, Receipt> {
    constructor();
    encode(value: Receipt): Uint8Array;
    decode(data: Uint8Array, offset: number): [Receipt, number];
}

type StorageSlot = {
    /** Key (b256) */
    key: string;
    /** Value (b256) */
    value: string;
};
declare class StorageSlotCoder extends StructCoder<{
    key: B256Coder;
    value: B256Coder;
}> {
    constructor();
}

type Witness = {
    /** Length of witness data, in bytes (u32) */
    dataLength: number;
    /** Witness data (byte[]) */
    data: string;
};
declare class WitnessCoder extends Coder<Witness, Witness> {
    constructor();
    encode(value: Witness): Uint8Array;
    decode(data: Uint8Array, offset: number): [Witness, number];
}

declare enum TransactionType {
    Script = 0,
    Create = 1,
    Mint = 2
}
type TransactionScript = {
    type: TransactionType.Script;
    /** Gas price for transaction (u64) */
    gasPrice: BN;
    /** Gas limit for transaction (u64) */
    gasLimit: BN;
    /** Block until which tx cannot be included (u32) */
    maturity: number;
    /** Script length, in instructions (u16) */
    scriptLength: number;
    /** Length of script input data, in bytes (u16) */
    scriptDataLength: number;
    /** Number of inputs (u8) */
    inputsCount: number;
    /** Number of outputs (u8) */
    outputsCount: number;
    /** Number of witnesses (u8) */
    witnessesCount: number;
    /** Merkle root of receipts (b256) */
    receiptsRoot: string;
    /** Script to execute (byte[]) */
    script: string;
    /** Script input data (parameters) (byte[]) */
    scriptData: string;
    /** List of inputs (Input[]) */
    inputs: Input[];
    /** List of outputs (Output[]) */
    outputs: Output[];
    /** List of witnesses (Witness[]) */
    witnesses: Witness[];
};
declare class TransactionScriptCoder extends Coder<TransactionScript, TransactionScript> {
    constructor();
    encode(value: TransactionScript): Uint8Array;
    decode(data: Uint8Array, offset: number): [TransactionScript, number];
}
type TransactionCreate = {
    type: TransactionType.Create;
    /** Gas price for transaction (u64) */
    gasPrice: BN;
    /** Gas limit for transaction (u64) */
    gasLimit: BN;
    /** Block until which tx cannot be included (u32) */
    maturity: number;
    /** Contract bytecode length, in instructions (u16) */
    bytecodeLength: number;
    /** Witness index of contract bytecode to create (u8) */
    bytecodeWitnessIndex: number;
    /** Number of storage slots to initialize (u16) */
    storageSlotsCount: number;
    /** Number of inputs (u8) */
    inputsCount: number;
    /** Number of outputs (u8) */
    outputsCount: number;
    /** Number of witnesses (u8) */
    witnessesCount: number;
    /** Salt (b256) */
    salt: string;
    /** List of inputs (StorageSlot[]) */
    storageSlots: StorageSlot[];
    /** List of inputs (Input[]) */
    inputs: Input[];
    /** List of outputs (Output[]) */
    outputs: Output[];
    /** List of witnesses (Witness[]) */
    witnesses: Witness[];
};
declare class TransactionCreateCoder extends Coder<TransactionCreate, TransactionCreate> {
    constructor();
    encode(value: TransactionCreate): Uint8Array;
    decode(data: Uint8Array, offset: number): [TransactionCreate, number];
}
type TransactionMint = {
    type: TransactionType.Mint;
    /** Number of outputs (u8) */
    outputsCount: number;
    /** List of outputs (Output[]) */
    outputs: Output[];
    /** The location of the Mint transaction in the block. */
    txPointer: TxPointer;
};
declare class TransactionMintCoder extends Coder<TransactionMint, TransactionMint> {
    constructor();
    encode(value: TransactionMint): Uint8Array;
    decode(data: Uint8Array, offset: number): [TransactionMint, number];
}
type PossibleTransactions = TransactionScript | TransactionCreate | TransactionMint;
type Transaction<TTransactionType = void> = TTransactionType extends TransactionType ? Extract<PossibleTransactions, {
    type: TTransactionType;
}> : Partial<Omit<TransactionScript, 'type'>> & Partial<Omit<TransactionCreate, 'type'>> & Partial<Omit<TransactionMint, 'type'>> & {
    type: TransactionType;
};
declare class TransactionCoder extends Coder<Transaction, Transaction> {
    constructor();
    encode(value: Transaction): Uint8Array;
    decode(data: Uint8Array, offset: number): [Transaction, number];
}

declare class ByteArrayCoder extends Coder<BytesLike, string> {
    #private;
    length: number;
    constructor(length: number);
    encode(value: BytesLike): Uint8Array;
    decode(data: Uint8Array, offset: number): [string, number];
}

export { ByteArrayCoder, Input, InputCoder, InputCoin, InputCoinCoder, InputContract, InputContractCoder, InputMessage, InputMessageCoder, InputType, Output, OutputChange, OutputChangeCoder, OutputCoder, OutputCoin, OutputCoinCoder, OutputContract, OutputContractCoder, OutputContractCreated, OutputContractCreatedCoder, OutputMessage, OutputMessageCoder, OutputType, OutputVariable, OutputVariableCoder, Receipt, ReceiptCall, ReceiptCallCoder, ReceiptCoder, ReceiptLog, ReceiptLogCoder, ReceiptLogData, ReceiptLogDataCoder, ReceiptMessageOut, ReceiptMessageOutCoder, ReceiptPanic, ReceiptPanicCoder, ReceiptReturn, ReceiptReturnCoder, ReceiptReturnData, ReceiptReturnDataCoder, ReceiptRevert, ReceiptRevertCoder, ReceiptScriptResult, ReceiptScriptResultCoder, ReceiptTransfer, ReceiptTransferCoder, ReceiptTransferOut, ReceiptTransferOutCoder, ReceiptType, StorageSlot, StorageSlotCoder, Transaction, TransactionCoder, TransactionCreate, TransactionCreateCoder, TransactionMint, TransactionMintCoder, TransactionScript, TransactionScriptCoder, TransactionType, TxPointer, TxPointerCoder, UtxoId, UtxoIdCoder, Witness, WitnessCoder };
