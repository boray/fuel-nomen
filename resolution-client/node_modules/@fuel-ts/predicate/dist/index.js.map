{"version":3,"sources":["../src/index.ts","../src/predicate.ts","../src/utils/getContractRoot.ts"],"sourcesContent":["export * from './predicate';\n","import type { BytesLike } from '@ethersproject/bytes';\nimport { hexlify, arrayify } from '@ethersproject/bytes';\nimport { Logger } from '@ethersproject/logger';\nimport { AbiCoder, Interface } from '@fuel-ts/abi-coder';\nimport type { JsonAbiFragmentType, JsonAbi, InputValue } from '@fuel-ts/abi-coder';\nimport { Address } from '@fuel-ts/address';\nimport type {\n  CallResult,\n  Provider,\n  TransactionRequestLike,\n  TransactionResponse,\n} from '@fuel-ts/providers';\nimport { transactionRequestify } from '@fuel-ts/providers';\nimport { InputType } from '@fuel-ts/transactions';\nimport { versions } from '@fuel-ts/versions';\nimport { Account } from '@fuel-ts/wallet';\n\nimport { getContractRoot } from './utils';\n\nconst logger = new Logger(versions.FUELS);\n\nexport class Predicate<ARGS extends InputValue[]> extends Account {\n  bytes: Uint8Array;\n  types?: ReadonlyArray<JsonAbiFragmentType>;\n  predicateData: Uint8Array = Uint8Array.from([]);\n  interface?: Interface;\n\n  constructor(bytes: BytesLike, types?: JsonAbi, provider?: string | Provider) {\n    const address = Address.fromB256(getContractRoot(bytes));\n    super(address, provider);\n\n    // Assign bytes data\n    this.bytes = arrayify(bytes);\n\n    if (types) {\n      this.interface = new Interface(types as JsonAbi);\n      const mainFunction = this.interface.fragments.find(({ name }) => name === 'main');\n      if (mainFunction !== undefined) {\n        this.types = mainFunction.inputs;\n      } else {\n        logger.throwArgumentError(\n          'Cannot use ABI without \"main\" function',\n          'Function fragments',\n          this.interface.fragments\n        );\n      }\n    }\n  }\n\n  populateTransactionPredicateData(transactionRequestLike: TransactionRequestLike) {\n    const request = transactionRequestify(transactionRequestLike);\n\n    request.inputs?.forEach((input) => {\n      if (input.type === InputType.Coin && hexlify(input.owner) === this.address.toB256()) {\n        // eslint-disable-next-line no-param-reassign\n        input.predicate = this.bytes;\n        // eslint-disable-next-line no-param-reassign\n        input.predicateData = this.predicateData;\n      }\n    });\n\n    return request;\n  }\n\n  sendTransaction(transactionRequestLike: TransactionRequestLike): Promise<TransactionResponse> {\n    const transactionRequest = this.populateTransactionPredicateData(transactionRequestLike);\n    return super.sendTransaction(transactionRequest);\n  }\n\n  simulateTransaction(transactionRequestLike: TransactionRequestLike): Promise<CallResult> {\n    const transactionRequest = this.populateTransactionPredicateData(transactionRequestLike);\n    return super.simulateTransaction(transactionRequest);\n  }\n\n  setData<T extends ARGS>(...args: T) {\n    const abiCoder = new AbiCoder();\n    const encoded = abiCoder.encode(this.types || [], args);\n    this.predicateData = encoded;\n    return this;\n  }\n}\n","import type { BytesLike } from '@ethersproject/bytes';\nimport { hexlify, arrayify } from '@ethersproject/bytes';\nimport { calcRoot } from '@fuel-ts/merkle';\n\nexport const getContractRoot = (bytecode: BytesLike): string => {\n  const chunkSize = 8;\n  const chunks: Uint8Array[] = [];\n  const bytes = arrayify(bytecode);\n\n  for (let offset = 0; offset < bytes.length; offset += chunkSize) {\n    const chunk = new Uint8Array(chunkSize);\n    chunk.set(bytes.slice(offset, offset + chunkSize));\n    chunks.push(chunk);\n  }\n\n  return calcRoot(chunks.map((c) => hexlify(c)));\n};\n"],"mappings":"yaAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,eAAAE,IAAA,eAAAC,EAAAH,GCCA,IAAAI,EAAkC,gCAClCC,EAAuB,iCACvBC,EAAoC,8BAEpCC,EAAwB,4BAOxBC,EAAsC,8BACtCC,EAA0B,iCAC1BC,EAAyB,6BACzBC,EAAwB,2BCdxB,IAAAC,EAAkC,gCAClCC,EAAyB,2BAEZC,EAAmBC,GAAgC,CAE9D,IAAMC,EAAuB,CAAC,EACxBC,KAAQ,YAASF,CAAQ,EAE/B,QAASG,EAAS,EAAGA,EAASD,EAAM,OAAQC,GAAU,EAAW,CAC/D,IAAMC,EAAQ,IAAI,WAAW,CAAS,EACtCA,EAAM,IAAIF,EAAM,MAAMC,EAAQA,EAAS,CAAS,CAAC,EACjDF,EAAO,KAAKG,CAAK,CACnB,CAEA,SAAO,YAASH,EAAO,IAAKI,MAAM,WAAQA,CAAC,CAAC,CAAC,CAC/C,EDGA,IAAMC,EAAS,IAAI,SAAO,WAAS,KAAK,EAE3BC,EAAN,cAAmD,SAAQ,CAChE,MACA,MACA,cAA4B,WAAW,KAAK,CAAC,CAAC,EAC9C,UAEA,YAAYC,EAAkBC,EAAiBC,EAA8B,CAC3E,IAAMC,EAAU,UAAQ,SAASC,EAAgBJ,CAAK,CAAC,EAMvD,GALA,MAAMG,EAASD,CAAQ,EAGvB,KAAK,SAAQ,YAASF,CAAK,EAEvBC,EAAO,CACT,KAAK,UAAY,IAAI,YAAUA,CAAgB,EAC/C,IAAMI,EAAe,KAAK,UAAU,UAAU,KAAK,CAAC,CAAE,KAAAC,CAAK,IAAMA,IAAS,MAAM,EAC5ED,IAAiB,OACnB,KAAK,MAAQA,EAAa,OAE1BP,EAAO,mBACL,yCACA,qBACA,KAAK,UAAU,SACjB,CAEJ,CACF,CAEA,iCAAiCS,EAAgD,CAjDnF,IAAAC,EAkDI,IAAMC,KAAU,yBAAsBF,CAAsB,EAE5D,OAAAC,EAAAC,EAAQ,SAAR,MAAAD,EAAgB,QAASE,GAAU,CAC7BA,EAAM,OAAS,YAAU,SAAQ,WAAQA,EAAM,KAAK,IAAM,KAAK,QAAQ,OAAO,IAEhFA,EAAM,UAAY,KAAK,MAEvBA,EAAM,cAAgB,KAAK,cAE/B,GAEOD,CACT,CAEA,gBAAgBF,EAA8E,CAC5F,IAAMI,EAAqB,KAAK,iCAAiCJ,CAAsB,EACvF,OAAO,MAAM,gBAAgBI,CAAkB,CACjD,CAEA,oBAAoBJ,EAAqE,CACvF,IAAMI,EAAqB,KAAK,iCAAiCJ,CAAsB,EACvF,OAAO,MAAM,oBAAoBI,CAAkB,CACrD,CAEA,WAA2BC,EAAS,CAElC,IAAMC,EADW,IAAI,WAAS,EACL,OAAO,KAAK,OAAS,CAAC,EAAGD,CAAI,EACtD,YAAK,cAAgBC,EACd,IACT,CACF","names":["src_exports","__export","Predicate","__toCommonJS","import_bytes","import_logger","import_abi_coder","import_address","import_providers","import_transactions","import_versions","import_wallet","import_bytes","import_merkle","getContractRoot","bytecode","chunks","bytes","offset","chunk","c","logger","Predicate","bytes","types","provider","address","getContractRoot","mainFunction","name","transactionRequestLike","_a","request","input","transactionRequest","args","encoded"]}