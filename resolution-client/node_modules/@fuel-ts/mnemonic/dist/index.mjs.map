{"version":3,"sources":["../src/mnemonic.ts","../src/utils.ts"],"sourcesContent":["import { Base58 } from '@ethersproject/basex';\nimport type { BytesLike } from '@ethersproject/bytes';\nimport { hexDataSlice, concat, hexlify, arrayify } from '@ethersproject/bytes';\nimport { pbkdf2 } from '@ethersproject/pbkdf2';\nimport { computeHmac, sha256, SupportedAlgorithm } from '@ethersproject/sha2';\nimport { randomBytes } from '@fuel-ts/keystore';\nimport { english } from '@fuel-ts/wordlists';\n\nimport type { MnemonicPhrase } from './utils';\nimport {\n  entropyToMnemonicIndices,\n  getWords,\n  getPhrase,\n  mnemonicWordsToEntropy,\n  toUtf8Bytes,\n} from './utils';\n\n//\n// Constants\n//\n// \"Bitcoin seed\"\nconst MasterSecret = toUtf8Bytes('Bitcoin seed');\n// 4 byte: version bytes (mainnet: 0x0488B21E public, 0x0488ADE4 private; testnet: 0x043587CF public, 0x04358394 private)\nconst MainnetPRV = 0x0488ade4;\nconst TestnetPRV = 0x04358394;\nexport const MNEMONIC_SIZES = [12, 15, 18, 21, 24];\n\nfunction assertWordList(wordlist: Array<string>) {\n  if (wordlist.length !== 2048) {\n    throw new Error('Invalid word list length');\n  }\n}\n\nfunction assertEntropy(entropy: BytesLike) {\n  if (entropy.length % 4 !== 0 || entropy.length < 16 || entropy.length > 32) {\n    throw new Error('invalid entropy');\n  }\n}\n\nfunction assertMnemonic(words: Array<string>) {\n  if (!MNEMONIC_SIZES.includes(words.length)) {\n    throw new Error('invalid mnemonic size');\n  }\n}\n\nclass Mnemonic {\n  wordlist: Array<string>;\n\n  /**\n   *\n   * @param wordlist - Provide a wordlist with the list of words used to generate the mnemonic phrase. The default value is the English list.\n   * @returns Mnemonic instance\n   */\n  constructor(wordlist: Array<string> = english) {\n    this.wordlist = wordlist;\n\n    assertWordList(this.wordlist);\n  }\n\n  /**\n   *\n   * @param phrase - Mnemonic phrase composed by words from the provided wordlist\n   * @returns Entropy hash\n   */\n  mnemonicToEntropy(phrase: MnemonicPhrase) {\n    return Mnemonic.mnemonicToEntropy(phrase, this.wordlist);\n  }\n\n  /**\n   *\n   * @param entropy - Entropy source to the mnemonic phrase.\n   * @returns Mnemonic phrase\n   */\n  entropyToMnemonic(entropy: BytesLike) {\n    return Mnemonic.entropyToMnemonic(entropy, this.wordlist);\n  }\n\n  /**\n   *\n   * @param phrase - Mnemonic phrase composed by words from the provided wordlist\n   * @param wordlist - Provide a wordlist with the list of words used to generate the mnemonic phrase. The default value is the English list.\n   * @returns Mnemonic phrase\n   */\n  static mnemonicToEntropy(phrase: MnemonicPhrase, wordlist: Array<string> = english): string {\n    const words = getWords(phrase);\n\n    assertMnemonic(words);\n\n    return hexlify(mnemonicWordsToEntropy(words, wordlist));\n  }\n\n  /**\n   * @param entropy - Entropy source to the mnemonic phrase.\n   * @param testnet - Inform if should use testnet or mainnet prefix, default value is true (`mainnet`).\n   * @returns 64-byte array contains privateKey and chainCode as described on BIP39\n   */\n  static entropyToMnemonic(entropy: BytesLike, wordlist: Array<string> = english): string {\n    const entropyBytes = arrayify(entropy, {\n      allowMissingPrefix: true,\n    });\n\n    assertWordList(wordlist);\n    assertEntropy(entropyBytes);\n\n    return entropyToMnemonicIndices(entropyBytes)\n      .map((i) => wordlist[i])\n      .join(' ');\n  }\n\n  /**\n   * @param phrase - Mnemonic phrase composed by words from the provided wordlist\n   * @param passphrase - Add additional security to protect the generated seed with a memorized passphrase. `Note: if the owner forgot the passphrase, all wallets and accounts derive from the phrase will be lost.`\n   * @returns 64-byte array contains privateKey and chainCode as described on BIP39\n   */\n  static mnemonicToSeed(phrase: MnemonicPhrase, passphrase: BytesLike = '') {\n    assertMnemonic(getWords(phrase));\n\n    const phraseBytes = toUtf8Bytes(getPhrase(phrase));\n    const salt = toUtf8Bytes(`mnemonic${passphrase}`);\n\n    return pbkdf2(phraseBytes, salt, 2048, 64, 'sha512');\n  }\n\n  /**\n   * @param phrase - Mnemonic phrase composed by words from the provided wordlist\n   * @param passphrase - Add additional security to protect the generated seed with a memorized passphrase. `Note: if the owner forgot the passphrase, all wallets and accounts derive from the phrase will be lost.`\n   * @returns 64-byte array contains privateKey and chainCode as described on BIP39\n   */\n  static mnemonicToMasterKeys(phrase: MnemonicPhrase, passphrase: BytesLike = '') {\n    const seed = Mnemonic.mnemonicToSeed(phrase, passphrase);\n    return Mnemonic.masterKeysFromSeed(seed);\n  }\n\n  /**\n   * Validates if given mnemonic is  valid\n   * @param phrase - Mnemonic phrase composed by words from the provided wordlist\n   * @returns true if phrase is a valid mnemonic\n   */\n  static isMnemonicValid(phrase: string) {\n    const words = getWords(phrase);\n\n    let i: number = 0;\n\n    try {\n      assertMnemonic(words);\n    } catch {\n      return false;\n    }\n\n    while (i < words.length) {\n      if (Mnemonic.binarySearch(words[i]) === false) return false;\n      i += 1;\n    }\n\n    return true;\n  }\n\n  static binarySearch(target: string): boolean {\n    const words = english;\n    let left: number = 0;\n    let right: number = words.length - 1;\n\n    while (left <= right) {\n      const mid: number = Math.floor((left + right) / 2);\n\n      if (words[mid] === target) return true;\n      if (target < words[mid]) right = mid - 1;\n      else left = mid + 1;\n    }\n\n    return false;\n  }\n\n  /**\n   * @param seed - BIP39 seed\n   * @param testnet - Inform if should use testnet or mainnet prefix, the default value is true (`mainnet`).\n   * @returns 64-byte array contains privateKey and chainCode as described on BIP39\n   */\n  static masterKeysFromSeed(seed: string): Uint8Array {\n    const seedArray = arrayify(seed);\n\n    if (seedArray.length < 16 || seedArray.length > 64) {\n      throw new Error('invalid seed');\n    }\n\n    return arrayify(computeHmac(SupportedAlgorithm.sha512, MasterSecret, seedArray));\n  }\n\n  /**\n   * Get the extendKey as defined on BIP-32 from the provided seed\n   *\n   * @param seed - BIP39 seed\n   * @param testnet - Inform if should use testnet or mainnet prefix, default value is true (`mainnet`).\n   * @returns BIP-32 extended private key\n   */\n  static seedToExtendedKey(seed: string, testnet: boolean = false): string {\n    const masterKey = Mnemonic.masterKeysFromSeed(seed);\n    const prefix = arrayify(testnet ? TestnetPRV : MainnetPRV);\n    const depth = '0x00';\n    const fingerprint = '0x00000000';\n    const index = '0x00000000';\n    // last 32 bites from the key\n    const chainCode = masterKey.slice(32);\n    // first 32 bites from the key\n    const privateKey = masterKey.slice(0, 32);\n    const extendedKey = concat([\n      prefix,\n      depth,\n      fingerprint,\n      index,\n      chainCode,\n      concat(['0x00', privateKey]),\n    ]);\n    const checksum = hexDataSlice(sha256(sha256(extendedKey)), 0, 4);\n\n    return Base58.encode(concat([extendedKey, checksum]));\n  }\n\n  /**\n   *  Create a new mnemonic using a randomly generated number as entropy.\n   *  As defined in BIP39, the entropy must be a multiple of 32 bits, and its size must be between 128 and 256 bits.\n   *  Therefore, the possible values for `strength` are 128, 160, 192, 224, and 256.\n   *  If not provided, the default entropy length will be set to 256 bits.\n   *  The return is a list of words that encodes the generated entropy.\n   *\n   *\n   * @param size - Number of bytes used as an entropy\n   * @param extraEntropy - Optional extra entropy to increase randomness\n   * @returns A randomly generated mnemonic\n   */\n  static generate(size: number = 32, extraEntropy: BytesLike = '') {\n    const entropy = extraEntropy\n      ? sha256(concat([randomBytes(size), arrayify(extraEntropy)]))\n      : randomBytes(size);\n    return Mnemonic.entropyToMnemonic(entropy);\n  }\n}\n\nexport default Mnemonic;\n","import type { BytesLike } from '@ethersproject/bytes';\nimport { arrayify } from '@ethersproject/bytes';\nimport { sha256 } from '@ethersproject/sha2';\n\n/* Mnemonic phrase composed by words from the provided wordlist it can be a text or a array of words */\nexport type MnemonicPhrase = string | Array<string>;\n\nexport function toUtf8Bytes(stri: string): Uint8Array {\n  const str = stri.normalize('NFKD');\n\n  const result = [];\n  for (let i = 0; i < str.length; i += 1) {\n    const c = str.charCodeAt(i);\n\n    if (c < 0x80) {\n      result.push(c);\n    } else if (c < 0x800) {\n      result.push((c >> 6) | 0xc0);\n      result.push((c & 0x3f) | 0x80);\n    } else if ((c & 0xfc00) === 0xd800) {\n      i += 1;\n      const c2 = str.charCodeAt(i);\n\n      if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n        throw new Error('invalid utf-8 string');\n      }\n\n      // Surrogate Pair\n      const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n      result.push((pair >> 18) | 0xf0);\n      result.push(((pair >> 12) & 0x3f) | 0x80);\n      result.push(((pair >> 6) & 0x3f) | 0x80);\n      result.push((pair & 0x3f) | 0x80);\n    } else {\n      result.push((c >> 12) | 0xe0);\n      result.push(((c >> 6) & 0x3f) | 0x80);\n      result.push((c & 0x3f) | 0x80);\n    }\n  }\n\n  return arrayify(result);\n}\n\n// Returns a byte with the LSB bits set\nfunction getLowerMask(bits: number): number {\n  return (1 << bits) - 1;\n}\n\n// Returns a byte with the MSB bits set\nfunction getUpperMask(bits: number): number {\n  return ((1 << bits) - 1) << (8 - bits);\n}\n\nexport function getWords(mnemonic: MnemonicPhrase): Array<string> {\n  if (!Array.isArray(mnemonic)) {\n    return mnemonic.split(/\\s+/);\n  }\n  return mnemonic;\n}\n\nexport function getPhrase(mnemonic: MnemonicPhrase): string {\n  if (Array.isArray(mnemonic)) {\n    return mnemonic.join(' ');\n  }\n  return mnemonic;\n}\n\nexport function entropyToMnemonicIndices(entropy: Uint8Array): Array<number> {\n  const indices: Array<number> = [0];\n\n  let remainingBits = 11;\n  for (let i = 0; i < entropy.length; i += 1) {\n    if (remainingBits > 8) {\n      indices[indices.length - 1] <<= 8;\n      indices[indices.length - 1] |= entropy[i];\n\n      remainingBits -= 8;\n      // This byte will complete an 11-bit index\n    } else {\n      indices[indices.length - 1] <<= remainingBits;\n      indices[indices.length - 1] |= entropy[i] >> (8 - remainingBits);\n\n      // Start the next word\n      indices.push(entropy[i] & getLowerMask(8 - remainingBits));\n\n      remainingBits += 3;\n    }\n  }\n\n  // Compute the checksum bits\n  const checksumBits = entropy.length / 4;\n  const checksum = arrayify(sha256(entropy))[0] & getUpperMask(checksumBits);\n\n  // Shift the checksum into the word indices\n  indices[indices.length - 1] <<= checksumBits;\n  indices[indices.length - 1] |= checksum >> (8 - checksumBits);\n\n  return indices;\n}\n\nexport function mnemonicWordsToEntropy(words: Array<string>, wordlist: Array<string>): BytesLike {\n  const size = Math.ceil((11 * words.length) / 8);\n  const entropy = arrayify(new Uint8Array(size));\n\n  let offset = 0;\n  for (let i = 0; i < words.length; i += 1) {\n    const index = wordlist.indexOf(words[i].normalize('NFKD'));\n    if (index === -1) {\n      throw new Error('invalid mnemonic');\n    }\n\n    for (let bit = 0; bit < 11; bit += 1) {\n      if (index & (1 << (10 - bit))) {\n        entropy[offset >> 3] |= 1 << (7 - (offset % 8));\n      }\n      offset += 1;\n    }\n  }\n  const entropyBits = (32 * words.length) / 3;\n  const checksumBits = words.length / 3;\n  const checksumMask = getUpperMask(checksumBits);\n  const checksum = arrayify(sha256(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;\n\n  if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {\n    throw new Error('invalid checksum');\n  }\n\n  return entropy.slice(0, entropyBits / 8);\n}\n"],"mappings":"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","names":["Base58","hexDataSlice","concat","hexlify","arrayify","pbkdf2","computeHmac","sha256","SupportedAlgorithm","randomBytes","english","arrayify","sha256","toUtf8Bytes","stri","str","result","i","c","c2","pair","getLowerMask","bits","getUpperMask","getWords","mnemonic","getPhrase","entropyToMnemonicIndices","entropy","indices","remainingBits","checksumBits","checksum","mnemonicWordsToEntropy","words","wordlist","size","offset","index","bit","entropyBits","checksumMask","MasterSecret","toUtf8Bytes","MainnetPRV","TestnetPRV","MNEMONIC_SIZES","assertWordList","wordlist","assertEntropy","entropy","assertMnemonic","words","Mnemonic","english","phrase","getWords","hexlify","mnemonicWordsToEntropy","entropyBytes","arrayify","entropyToMnemonicIndices","i","passphrase","phraseBytes","getPhrase","salt","pbkdf2","seed","target","left","right","mid","seedArray","computeHmac","SupportedAlgorithm","testnet","masterKey","prefix","depth","fingerprint","index","chainCode","privateKey","extendedKey","concat","checksum","hexDataSlice","sha256","Base58","size","extraEntropy","randomBytes","mnemonic_default"]}