import { BytesLike } from '@ethersproject/bytes';
import { BN, BNInput } from '@fuel-ts/math';
import { RequireExactlyOne } from 'type-fest';

type InputValueOf$4<TCoders extends Record<string, Coder>> = RequireExactlyOne<{
    [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Input'];
}>;
type DecodedValueOf$4<TCoders extends Record<string, Coder>> = RequireExactlyOne<{
    [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Decoded'];
}>;
declare class EnumCoder<TCoders extends Record<string, Coder>> extends Coder<InputValueOf$4<TCoders>, DecodedValueOf$4<TCoders>> {
    #private;
    name: string;
    coders: TCoders;
    constructor(name: string, coders: TCoders);
    encode(value: InputValueOf$4<TCoders>): Uint8Array;
    decode(data: Uint8Array, offset: number): [DecodedValueOf$4<TCoders>, number];
}

type Option<T> = T | undefined;

type Primitive = string | number | boolean;
/**
 * The type of value you can provide to `Coder.encode`
 */
type InputValue<T = void> = Primitive | BN | Option<T> | BytesLike | InputValue[] | {
    [key: string]: InputValue;
} | Record<string, Primitive | BytesLike>;
/**
 * The type of value you can get from `Coder.decode`
 */
type DecodedValue = Primitive | DecodedValue[] | {
    [key: string]: DecodedValue;
} | Record<string, Primitive>;
type TypesOfCoder<TCoder> = TCoder extends Coder<infer TInput, infer TDecoded> ? {
    Input: TInput;
    Decoded: TDecoded;
} : never;
declare abstract class Coder<TInput = unknown, TDecoded = unknown> {
    readonly name: string;
    readonly type: string;
    readonly encodedLength: number;
    offset?: number;
    constructor(name: string, type: string, encodedLength: number);
    throwError(message: string, value: unknown): never;
    setOffset(offset: number): void;
    abstract encode(value: TInput, length?: number): Uint8Array;
    abstract decode(data: Uint8Array, offset: number, length?: number): [TDecoded, number];
}

type InputValueOf$3<TCoder extends Coder> = Array<TypesOfCoder<TCoder>['Input']>;
type DecodedValueOf$3<TCoder extends Coder> = Array<TypesOfCoder<TCoder>['Decoded']>;
declare class ArrayCoder<TCoder extends Coder> extends Coder<InputValueOf$3<TCoder>, DecodedValueOf$3<TCoder>> {
    coder: TCoder;
    length: number;
    constructor(coder: TCoder, length: number);
    encode(value: InputValueOf$3<TCoder>): Uint8Array;
    decode(data: Uint8Array, offset: number): [DecodedValueOf$3<TCoder>, number];
}

declare class B256Coder extends Coder<string, string> {
    constructor();
    encode(value: string): Uint8Array;
    decode(data: Uint8Array, offset: number): [string, number];
}

declare class B512Coder extends Coder<string, string> {
    constructor();
    encode(value: string): Uint8Array;
    decode(data: Uint8Array, offset: number): [string, number];
}

declare class BooleanCoder extends Coder<boolean, boolean> {
    constructor();
    encode(value: boolean): Uint8Array;
    decode(data: Uint8Array, offset: number): [boolean, number];
}

declare class ByteCoder extends Coder<number, number> {
    constructor();
    encode(value: number): Uint8Array;
    decode(data: Uint8Array, offset: number): [number, number];
}

type NumberCoderType = 'u8' | 'u16' | 'u32';
declare class NumberCoder extends Coder<number, number> {
    length: number;
    baseType: NumberCoderType;
    constructor(baseType: NumberCoderType);
    encode(value: number | string): Uint8Array;
    decode(data: Uint8Array, offset: number): [number, number];
}

declare class StringCoder<TLength extends number = number> extends Coder<string, string> {
    #private;
    length: TLength;
    constructor(length: TLength);
    encode(value: string): Uint8Array;
    decode(data: Uint8Array, offset: number): [string, number];
}

type InputValueOf$2<TCoders extends Record<string, Coder>> = {
    [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Input'];
};
type DecodedValueOf$2<TCoders extends Record<string, Coder>> = {
    [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Decoded'];
};
declare class StructCoder<TCoders extends Record<string, Coder>> extends Coder<InputValueOf$2<TCoders>, DecodedValueOf$2<TCoders>> {
    name: string;
    coders: TCoders;
    constructor(name: string, coders: TCoders);
    encode(value: InputValueOf$2<TCoders>): Uint8Array;
    decode(data: Uint8Array, offset: number): [DecodedValueOf$2<TCoders>, number];
}

type InputValueOf$1<TCoders extends Coder[]> = {
    [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Input'];
};
type DecodedValueOf$1<TCoders extends Coder[]> = {
    [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Decoded'];
};
declare class TupleCoder<TCoders extends Coder[]> extends Coder<InputValueOf$1<TCoders>, DecodedValueOf$1<TCoders>> {
    coders: TCoders;
    constructor(coders: TCoders);
    encode(value: InputValueOf$1<TCoders>): Uint8Array;
    decode(data: Uint8Array, offset: number): [DecodedValueOf$1<TCoders>, number];
}

declare class U64Coder extends Coder<BNInput, BN> {
    constructor();
    encode(value: BNInput): Uint8Array;
    decode(data: Uint8Array, offset: number): [BN, number];
}

type InputValueOf<TCoder extends Coder> = Array<TypesOfCoder<TCoder>['Input']>;
type DecodedValueOf<TCoder extends Coder> = Array<TypesOfCoder<TCoder>['Decoded']>;
declare class VecCoder<TCoder extends Coder> extends Coder<InputValueOf<TCoder>, DecodedValueOf<TCoder>> {
    coder: TCoder;
    constructor(coder: TCoder);
    static getBaseOffset(): number;
    getEncodedVectorData(value: InputValueOf<TCoder>): Uint8Array;
    encode(value: InputValueOf<TCoder>): Uint8Array;
    decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoder>, number];
}

declare function filterEmptyParams<T>(types: T): T;
declare function hasOptionTypes<T>(types: T): T;
declare function getVectorAdjustments(coders: Coder<unknown, unknown>[], values: InputValue[], offset?: number): Uint8Array[];

interface JsonFragmentType {
    readonly name?: string;
    readonly type: string;
    readonly components?: ReadonlyArray<JsonFragmentType>;
    readonly typeArguments?: ReadonlyArray<JsonFragmentType>;
}
interface ParamTypeProps {
    readonly name?: string;
    readonly type: string;
    readonly components?: Array<ParamType>;
    readonly typeArguments?: Array<ParamType>;
    readonly isParamType?: boolean;
}
declare class ParamType implements ParamTypeProps {
    readonly name?: string;
    readonly type: string;
    readonly indexed?: boolean;
    readonly components?: Array<ParamType>;
    readonly typeArguments?: Array<ParamType>;
    readonly isParamType?: boolean;
    constructor(params: ParamTypeProps);
    getSignaturePrefix(): string;
    getSignatureContent(): string;
    getSighash(): string;
    static fromObject(value: JsonFragmentType | ParamTypeProps): ParamType;
    static isParamType(value?: JsonFragmentType | ParamType): value is ParamType;
}

interface AttributeType {
    readonly name: string;
    readonly arguments: ReadonlyArray<string>;
}
interface FragmentParams {
    readonly type: string;
    readonly name: string;
    readonly inputs: Array<ParamType>;
    readonly outputs: Array<ParamType>;
    readonly attributes: ReadonlyArray<AttributeType>;
}
declare abstract class Fragment {
    readonly type: string;
    readonly name: string;
    readonly inputs: Array<ParamType>;
    readonly outputs: Array<ParamType>;
    readonly attributes: ReadonlyArray<AttributeType>;
    constructor(params: FragmentParams);
    abstract getInputsSighash(format?: string): string;
}

/**
 * Types for Fuel JSON ABI Format as defined on:
 * https://github.com/FuelLabs/fuel-specs/blob/master/specs/protocol/abi.md#json-abi-format
 */
interface JsonAbiFragmentType {
    readonly type: string;
    readonly name?: string;
    readonly components?: ReadonlyArray<JsonAbiFragmentType> | null;
    readonly typeArguments?: ReadonlyArray<JsonAbiFragmentType> | null;
}
interface JsonAbiFunctionAttributeType {
    readonly name: string;
    readonly arguments: ReadonlyArray<string>;
}
interface JsonAbiFragment {
    readonly type: 'function' | string;
    readonly name: string;
    readonly inputs?: ReadonlyArray<JsonAbiFragmentType>;
    readonly outputs?: ReadonlyArray<JsonAbiFragmentType>;
    readonly attributes?: ReadonlyArray<JsonAbiFunctionAttributeType>;
}
interface JsonAbiLogFragment {
    readonly logId: number;
    readonly loggedType: JsonFlatAbiFragmentArgumentType;
    readonly abiFragmentType?: ReadonlyArray<JsonAbiFragmentType>;
}
interface JsonFlatAbiFragmentType {
    readonly typeId: number;
    readonly type: string;
    readonly name?: string;
    readonly components?: ReadonlyArray<JsonFlatAbiFragmentArgumentType> | null;
    readonly typeParameters?: ReadonlyArray<number> | null;
}
interface JsonFlatAbiFragmentLoggedType {
    readonly logId: number;
    readonly loggedType: JsonFlatAbiFragmentArgumentType;
}
interface JsonFlatAbiFragmentArgumentType {
    readonly type: number;
    readonly name?: string;
    readonly typeArguments?: ReadonlyArray<JsonFlatAbiFragmentArgumentType> | null;
}
interface JsonFlatAbiFragmentFunction {
    readonly name: string;
    readonly inputs?: ReadonlyArray<JsonFlatAbiFragmentArgumentType>;
    readonly output?: Readonly<JsonFlatAbiFragmentArgumentType>;
    readonly attributes?: ReadonlyArray<JsonAbiFunctionAttributeType> | null;
}
interface JsonFlatAbi {
    readonly types: ReadonlyArray<JsonFlatAbiFragmentType>;
    readonly loggedTypes: ReadonlyArray<JsonFlatAbiFragmentLoggedType>;
    readonly functions: ReadonlyArray<JsonFlatAbiFragmentFunction>;
}
declare const isFlatJsonAbi: (jsonAbi: JsonAbi) => jsonAbi is JsonFlatAbi;
/**
 * A JSON ABI object
 */
type JsonAbi = ReadonlyArray<JsonAbiFragment> | JsonFlatAbi;
declare class ABI {
    readonly types: ReadonlyArray<JsonFlatAbiFragmentType>;
    readonly functions: ReadonlyArray<JsonFlatAbiFragmentFunction>;
    readonly loggedTypes: ReadonlyArray<JsonFlatAbiFragmentLoggedType>;
    constructor(jsonAbi: JsonFlatAbi);
    parseLoggedType(loggedType: JsonFlatAbiFragmentLoggedType): JsonAbiFragmentType;
    parseInput(input: JsonFlatAbiFragmentArgumentType, typeArgumentsList?: Map<number, JsonAbiFragmentType>): JsonAbiFragmentType;
    static unflatten(jsonAbi: JsonAbi): readonly JsonAbiFragment[];
    unflattenLoggedTypes(): ReadonlyArray<JsonAbiLogFragment>;
    unflatten(): ReadonlyArray<JsonAbiFragment>;
}
/**
 * Checks if a given type is a reference type
 * See: https://github.com/FuelLabs/sway/issues/1368
 */
declare const isReferenceType: (type: string) => boolean;

declare class FunctionFragment extends Fragment {
    static fromObject(value: JsonAbiFragment): FunctionFragment;
    getInputsSighash(): string;
}

declare class AbiCoder {
    constructor();
    getCoder(param: JsonAbiFragmentType): Coder;
    encode(types: ReadonlyArray<JsonAbiFragmentType>, values: InputValue[], offset?: number): Uint8Array;
    decode(types: ReadonlyArray<JsonAbiFragmentType>, data: BytesLike): DecodedValue[] | undefined;
}

declare class Interface {
    readonly fragments: Array<Fragment>;
    readonly functions: {
        [name: string]: FunctionFragment;
    };
    readonly abiCoder: AbiCoder;
    readonly abi: ABI | null;
    readonly types: ReadonlyArray<JsonFlatAbiFragmentType>;
    readonly loggedTypes: ReadonlyArray<JsonAbiLogFragment>;
    private externalLoggedTypes;
    constructor(jsonAbi: JsonAbi | JsonFlatAbi);
    static getSighash(fragment: FunctionFragment | string): Uint8Array;
    getFunction(nameOrSignatureOrSighash: string): FunctionFragment;
    decodeFunctionData(functionFragment: FunctionFragment | string, data: BytesLike): any;
    encodeFunctionData(functionFragment: FunctionFragment | string, values: Array<InputValue>, offset?: number, isMainArgs?: boolean): Uint8Array;
    decodeFunctionResult(functionFragment: FunctionFragment | string, data: BytesLike): any;
    decodeLog(data: BytesLike, logId: number, receiptId: string): any;
    encodeFunctionResult(functionFragment: FunctionFragment | string, values: Array<InputValue>): Uint8Array;
    updateExternalLoggedTypes(id: string, loggedTypes: JsonAbiLogFragment[]): void;
}

declare const OPTION_CODER_TYPE = "enum Option";
declare const VEC_CODER_TYPE = "struct Vec";
declare const stringRegEx: RegExp;
declare const arrayRegEx: RegExp;
declare const structRegEx: RegExp;
declare const enumRegEx: RegExp;
declare const tupleRegEx: RegExp;
declare const genericRegEx: RegExp;
declare const WORD_SIZE = 8;
declare const BYTES_32 = 32;
declare const MAX_INPUTS = 255;
declare const ASSET_ID_LEN = 32;
declare const CONTRACT_ID_LEN = 32;
declare const VM_TX_MEMORY: number;
declare const TRANSACTION_SCRIPT_FIXED_SIZE: number;

export { ABI, ASSET_ID_LEN, AbiCoder, ArrayCoder, B256Coder, B512Coder, BYTES_32, BooleanCoder, ByteCoder, CONTRACT_ID_LEN, Coder, DecodedValue, EnumCoder, Fragment, FunctionFragment, InputValue, Interface, JsonAbi, JsonAbiFragment, JsonAbiFragmentType, JsonAbiFunctionAttributeType, JsonAbiLogFragment, JsonFlatAbi, JsonFlatAbiFragmentArgumentType, JsonFlatAbiFragmentFunction, JsonFlatAbiFragmentLoggedType, JsonFlatAbiFragmentType, MAX_INPUTS, NumberCoder, OPTION_CODER_TYPE, StringCoder, StructCoder, TRANSACTION_SCRIPT_FIXED_SIZE, TupleCoder, TypesOfCoder, U64Coder, VEC_CODER_TYPE, VM_TX_MEMORY, VecCoder, WORD_SIZE, arrayRegEx, enumRegEx, filterEmptyParams, genericRegEx, getVectorAdjustments, hasOptionTypes, isFlatJsonAbi, isReferenceType, stringRegEx, structRegEx, tupleRegEx };
