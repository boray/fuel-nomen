import{bn as b,toHex as m}from"@fuel-ts/math";import{hash as N}from"@fuel-ts/merkle-shared";var g=class{left;right;parent;hash;data;sum;index;constructor(o,t,n,e,u,i,s=0){this.left=o,this.right=t,this.parent=n,this.hash=e,this.sum=u,this.data=i,this.index=s}},c=g;var d=class{sideNodes;nodeSums;constructor(o,t){this.sideNodes=o,this.nodeSums=t}},x=d;function w(r,o){return N("0x00".concat(m(r,32).slice(2)).concat(o.slice(2)))}function S(r,o,t,n){return N("0x01".concat(m(r,32).slice(2)).concat(o.slice(2)).concat(m(t,32).slice(2)).concat(n.slice(2)))}function v(r,o){let t=[];for(let s=0,h=o.length;s<h;s+=1){let l=w(r[s],o[s]),p=new c(-1,-1,-1,l,r[s],o[s]);p.index=s,t.push(p)}let n=[...t],e=[...t],u=t.length+1>>1,i=t.length&1;for(;;){let s=0;for(;s<u-i;s+=1){let h=s<<1,l=S(e[h].sum,e[h].hash,e[h+1].sum,e[h+1].hash);t[s]=new c(e[h].index,e[h+1].index,-1,l,b(e[h].sum).add(e[h+1].sum).toHex(),""),t[s].index=n.length,n[e[h].index].parent=n.length,n[e[h+1].index].parent=n.length,n.push(t[s])}if(i===1&&(t[s]=e[s<<1]),u===1)break;i=u&1,u=u+1>>1,e=[...t]}return n}function R(r,o){let t=[];for(let i=0;i<o.length;i+=1){let s=w(r[i],o[i]);t.push(new c(-1,-1,-1,s,r[i],o[i]))}let n=t,e=t.length+1>>1,u=t.length&1;for(;;){let i=0;for(;i<e-u;i+=1){let s=i<<1,h=S(n[s].sum,n[s].hash,n[s+1].sum,n[s+1].hash);t[i]=new c(n[s].index,n[s+1].index,-1,h,b(n[s].sum).add(n[s+1].sum).toHex(),"")}if(u===1&&(t[i]=n[i<<1]),e===1)break;u=e&1,e=e+1>>1,n=t}return t[0]}function T(r,o){let t=new x([],[]);for(let n=o,e=r[o].parent;e!==-1;n=e,e=r[e].parent)r[e].left===n?(t.sideNodes.push(r[r[e].right].hash),t.nodeSums.push(r[r[e].right].sum)):(t.sideNodes.push(r[r[e].left].hash),t.nodeSums.push(r[r[e].left].sum));return t}export{R as calcRoot,v as constructTree,T as getProof,w as hashLeaf,S as hashNode};
//# sourceMappingURL=index.mjs.map