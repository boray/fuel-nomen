{"version":3,"sources":["../src/index.ts","../src/contract-factory.ts","../src/util.ts"],"sourcesContent":["export { default as ContractFactory } from './contract-factory';\nexport * as ContractUtils from './util';\n","import type { BytesLike } from '@ethersproject/bytes';\nimport { arrayify } from '@ethersproject/bytes';\nimport { Logger } from '@ethersproject/logger';\nimport { Interface } from '@fuel-ts/abi-coder';\nimport type { JsonAbi } from '@fuel-ts/abi-coder';\nimport { randomBytes } from '@fuel-ts/keystore';\nimport { Contract } from '@fuel-ts/program';\nimport type { CreateTransactionRequestLike, Provider } from '@fuel-ts/providers';\nimport { CreateTransactionRequest } from '@fuel-ts/providers';\nimport type { StorageSlot } from '@fuel-ts/transactions';\nimport { MAX_GAS_PER_TX } from '@fuel-ts/transactions/configs';\nimport { versions } from '@fuel-ts/versions';\nimport type { Account } from '@fuel-ts/wallet';\n\nimport { getContractId, getContractStorageRoot, includeHexPrefix } from './util';\n\nconst logger = new Logger(versions.FUELS);\n\ntype DeployContractOptions = {\n  salt?: BytesLike;\n  storageSlots?: StorageSlot[];\n  stateRoot?: BytesLike;\n} & CreateTransactionRequestLike;\n\nexport default class ContractFactory {\n  bytecode: BytesLike;\n  interface: Interface;\n  provider!: Provider | null;\n  account!: Account | null;\n\n  constructor(\n    bytecode: BytesLike,\n    abi: JsonAbi | Interface,\n    accountOrProvider: Account | Provider | null = null\n  ) {\n    // Force the bytecode to be a byte array\n    this.bytecode = arrayify(bytecode);\n\n    if (abi instanceof Interface) {\n      this.interface = abi;\n    } else {\n      this.interface = new Interface(abi);\n    }\n\n    /**\n      Instead of using `instanceof` to compare classes, we instead check\n      if `accountOrProvider` have a `provider` property inside. If yes,\n      than we assume it's a Wallet.\n\n      This approach is safer than using `instanceof` because it\n      there might be different versions and bundles of the library.\n\n      The same is done at:\n        - ./contract.ts\n\n      @see Contract\n    */\n    if (accountOrProvider && 'provider' in accountOrProvider) {\n      this.provider = accountOrProvider.provider;\n      this.account = accountOrProvider;\n    } else {\n      this.provider = accountOrProvider;\n      this.account = null;\n    }\n  }\n\n  connect(provider: Provider | null) {\n    return new ContractFactory(this.bytecode, this.interface, provider);\n  }\n\n  createTransactionRequest(deployContractOptions?: DeployContractOptions) {\n    const storageSlots = deployContractOptions?.storageSlots\n      ?.map(({ key, value }) => ({\n        key: includeHexPrefix(key),\n        value: includeHexPrefix(value),\n      }))\n      .sort(({ key: keyA }, { key: keyB }) => keyA.localeCompare(keyB));\n\n    const options = {\n      salt: randomBytes(32),\n      ...deployContractOptions,\n      storageSlots: storageSlots || [],\n    };\n\n    const stateRoot = options.stateRoot || getContractStorageRoot(options.storageSlots);\n    const contractId = getContractId(this.bytecode, options.salt, stateRoot);\n    const transactionRequest = new CreateTransactionRequest({\n      gasPrice: 0,\n      gasLimit: MAX_GAS_PER_TX,\n      bytecodeWitnessIndex: 0,\n      witnesses: [this.bytecode],\n      ...options,\n    });\n    transactionRequest.addContractCreatedOutput(contractId, stateRoot);\n\n    return {\n      contractId,\n      transactionRequest,\n    };\n  }\n\n  async deployContract(deployContractOptions?: DeployContractOptions) {\n    if (!this.account) {\n      return logger.throwArgumentError(\n        'Cannot deploy Contract without account',\n        'account',\n        this.account\n      );\n    }\n\n    const { contractId, transactionRequest } = this.createTransactionRequest(deployContractOptions);\n    await this.account.fund(transactionRequest);\n    const response = await this.account.sendTransaction(transactionRequest);\n    await response.wait();\n\n    return new Contract(contractId, this.interface, this.account);\n  }\n}\n","import type { BytesLike, DataOptions } from '@ethersproject/bytes';\nimport { hexlify, arrayify, concat } from '@ethersproject/bytes';\nimport { sha256 } from '@ethersproject/sha2';\nimport { calcRoot } from '@fuel-ts/merkle';\nimport SparseMerkleTree from '@fuel-ts/sparsemerkle';\nimport type { StorageSlot } from '@fuel-ts/transactions';\n\nexport const getContractRoot = (bytecode: BytesLike): string => {\n  const chunkSize = 8;\n  const chunks: Uint8Array[] = [];\n  const bytes = arrayify(bytecode);\n\n  for (let offset = 0; offset < bytes.length; offset += chunkSize) {\n    const chunk = new Uint8Array(chunkSize);\n    chunk.set(bytes.slice(offset, offset + chunkSize));\n    chunks.push(chunk);\n  }\n\n  return calcRoot(chunks.map((c) => hexlify(c)));\n};\n\nexport const getContractStorageRoot = (storageSlots: StorageSlot[]): string => {\n  const tree = new SparseMerkleTree();\n\n  storageSlots.forEach(({ key, value }) => tree.update(key, value));\n\n  return tree.root;\n};\n\nexport const getContractId = (\n  bytecode: BytesLike,\n  salt: BytesLike,\n  stateRoot: BytesLike\n): string => {\n  const root = getContractRoot(arrayify(bytecode));\n  const contractId = sha256(concat(['0x4655454C', salt, root, stateRoot]));\n  return contractId;\n};\n\nexport const includeHexPrefix = (value: string, options?: DataOptions) =>\n  hexlify(value, {\n    ...options,\n    allowMissingPrefix: true,\n  });\n"],"mappings":"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","names":["src_exports","__export","ContractFactory","util_exports","__toCommonJS","import_bytes","import_logger","import_abi_coder","import_keystore","import_program","import_providers","import_configs","import_versions","util_exports","__export","getContractId","getContractRoot","getContractStorageRoot","includeHexPrefix","import_bytes","import_sha2","import_merkle","import_sparsemerkle","getContractRoot","bytecode","chunks","bytes","offset","chunk","c","getContractStorageRoot","storageSlots","tree","SparseMerkleTree","key","value","getContractId","salt","stateRoot","root","includeHexPrefix","options","logger","ContractFactory","bytecode","abi","accountOrProvider","provider","deployContractOptions","_a","storageSlots","key","value","includeHexPrefix","keyA","keyB","options","stateRoot","getContractStorageRoot","contractId","getContractId","transactionRequest"]}