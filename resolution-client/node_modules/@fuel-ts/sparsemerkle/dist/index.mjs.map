{"version":3,"sources":["../src/sparseMerkleTree.ts","../src/proofs.ts","../src/treeHasher.ts","../src/types/sparseCompactMerkleProof.ts","../src/types/sparseMerkleProof.ts","../src/utils.ts"],"sourcesContent":["/// @dev The Fuel testing Merkle trees.\n/// A set of useful helper methods for testing and deploying Merkle trees.\nimport { hash } from '@fuel-ts/merkle-shared';\n\nimport { compactProof } from './proofs';\nimport { isLeaf, hashLeaf, hashNode, parseLeaf, parseNode } from './treeHasher';\nimport type SparseCompactMerkleProof from './types/sparseCompactMerkleProof';\nimport SparseMerkleProof from './types/sparseMerkleProof';\nimport type { MapStore } from './utils';\nimport { ZERO, MAX_HEIGHT, getBitAtFromMSB, reverseSideNodes, countCommonPrefix } from './utils';\n\nclass SparseMerkleTree {\n  ms: MapStore;\n\n  root: string;\n\n  constructor() {\n    const ms: MapStore = {};\n    this.ms = ms;\n    this.root = ZERO;\n    this.ms[this.root] = ZERO;\n  }\n\n  get(key: string): string {\n    return this.ms[key];\n  }\n\n  set(key: string, value: string): void {\n    this.ms[key] = value;\n  }\n\n  setRoot(root: string): void {\n    this.root = root;\n  }\n\n  sideNodesForRoot(key: string, root: string): [string[], string, string, string] {\n    const sideNodes: string[] = [];\n\n    // If the root is a placeholder, there are no sidenodes to return.\n    // The data is nil, and the sibling is nil\n    if (root === ZERO) {\n      return [sideNodes, ZERO, '', ''];\n    }\n\n    let currentData = this.get(root);\n\n    // If the root is a leaf, there are also no sidenodes to return.\n    // The data is the leaf data, and the sibling is nil\n    if (isLeaf(currentData)) {\n      return [sideNodes, root, currentData, ''];\n    }\n\n    let leftNode;\n    let rightNode;\n    let nodeHash = '';\n    let sideNode = '';\n\n    for (let i = 0; i < MAX_HEIGHT; i += 1) {\n      [leftNode, rightNode] = parseNode(currentData);\n\n      if (getBitAtFromMSB(key, i) === 1) {\n        sideNode = leftNode;\n        nodeHash = rightNode;\n      } else {\n        sideNode = rightNode;\n        nodeHash = leftNode;\n      }\n\n      sideNodes.push(sideNode);\n\n      // If the node is a placeholder, we've reached the end.\n      if (nodeHash === ZERO) {\n        currentData = '';\n        break;\n      }\n\n      currentData = this.get(nodeHash);\n\n      // If the node is a leaf, we've reached the end.\n      if (isLeaf(currentData)) {\n        break;\n      }\n    }\n\n    const siblingData = this.get(sideNode);\n\n    return [reverseSideNodes(sideNodes), nodeHash, currentData, siblingData];\n  }\n\n  deleteWithSideNodes(\n    key: string,\n    sideNodes: string[],\n    oldLeafHash: string,\n    oldLeafData: string\n  ): string {\n    // If value already zero, deletion changes nothing. Just return current root\n\n    if (oldLeafHash === ZERO) {\n      return this.root;\n    }\n\n    // If key is already empty (different key found in its place), deletion changed nothing. Just return current root\n    const [actualPath] = parseLeaf(oldLeafData);\n\n    if (actualPath !== key) {\n      return this.root;\n    }\n\n    let currentHash = '';\n    let currentData = '';\n    let sideNode = '';\n    let sideNodeValue = '';\n    let nonPlaceholderReached = false;\n\n    for (let i = 0; i < sideNodes.length; i += 1) {\n      if (sideNodes[i] === '') {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      sideNode = sideNodes[i];\n\n      if (currentData === '') {\n        sideNodeValue = this.get(sideNode);\n\n        if (isLeaf(sideNodeValue)) {\n          // This is the leaf sibling that needs to be percolated up the tree.\n          currentHash = sideNode;\n          currentData = sideNode;\n          // eslint-disable-next-line no-continue\n          continue;\n        } else {\n          // This is the node sibling that needs to be left in its place.\n          currentData = ZERO;\n          nonPlaceholderReached = true;\n        }\n      }\n\n      if (!nonPlaceholderReached && sideNode === ZERO) {\n        // We found another placeholder sibling node, keep going up the\n        // tree until we find the first sibling that is not a placeholder.\n        // eslint-disable-next-line no-continue\n        continue;\n      } else if (!nonPlaceholderReached) {\n        // We found the first sibling node that is not a placeholder, it is\n        // time to insert our leaf sibling node here.\n        nonPlaceholderReached = true;\n      }\n\n      if (getBitAtFromMSB(key, sideNodes.length - 1 - i) === 1) {\n        [currentHash, currentData] = hashNode(sideNode, currentData);\n      } else {\n        [currentHash, currentData] = hashNode(currentData, sideNode);\n      }\n      this.set(currentHash, currentData);\n      currentData = currentHash;\n    }\n\n    // The tree is empty; return placeholder value as root.\n    // How can currentHash be '' / nil if it's a hash ?\n    if (currentHash === '') {\n      currentHash = ZERO;\n    }\n\n    return currentHash;\n  }\n\n  updateWithSideNodes(\n    key: string,\n    value: string,\n    sideNodes: string[],\n    oldLeafHash: string,\n    oldLeafData: string\n  ): string {\n    let currentHash;\n    let currentData;\n\n    this.set(hash(value), value);\n\n    [currentHash, currentData] = hashLeaf(key, value);\n    this.set(currentHash, currentData);\n\n    currentData = currentHash;\n\n    // If the leaf node that sibling nodes lead to has a different actual path\n    // than the leaf node being updated, we need to create an intermediate node\n    // with this leaf node and the new leaf node as children.\n    //\n    // First, get the number of bits that the paths of the two leaf nodes share\n    // in common as a prefix.\n\n    let commonPrefixCount;\n\n    if (oldLeafHash === ZERO) {\n      commonPrefixCount = MAX_HEIGHT;\n    } else {\n      const [actualPath] = parseLeaf(oldLeafData);\n      commonPrefixCount = countCommonPrefix(key, actualPath);\n    }\n\n    if (commonPrefixCount !== MAX_HEIGHT) {\n      if (getBitAtFromMSB(key, commonPrefixCount) === 1) {\n        [currentHash, currentData] = hashNode(oldLeafHash, currentData);\n      } else {\n        [currentHash, currentData] = hashNode(currentData, oldLeafHash);\n      }\n      this.set(currentHash, currentData);\n      currentData = currentHash;\n    }\n\n    for (let i = 0; i < MAX_HEIGHT; i += 1) {\n      let sideNode;\n      const offsetOfSideNodes = MAX_HEIGHT - sideNodes.length;\n\n      // If there are no sidenodes at this height, but the number of\n      // bits that the paths of the two leaf nodes share in common is\n      // greater than this height, then we need to build up the tree\n      // to this height with placeholder values at siblings.\n\n      if (i - offsetOfSideNodes < 0 || sideNodes[i - offsetOfSideNodes] === '') {\n        if (commonPrefixCount !== MAX_HEIGHT && commonPrefixCount > MAX_HEIGHT - 1 - i) {\n          sideNode = ZERO;\n        } else {\n          // eslint-disable-next-line no-continue\n          continue;\n        }\n      } else {\n        sideNode = sideNodes[i - offsetOfSideNodes];\n      }\n\n      if (getBitAtFromMSB(key, MAX_HEIGHT - 1 - i) === 1) {\n        [currentHash, currentData] = hashNode(sideNode, currentData);\n      } else {\n        [currentHash, currentData] = hashNode(currentData, sideNode);\n      }\n\n      this.set(currentHash, currentData);\n      currentData = currentHash;\n    }\n\n    return currentHash;\n  }\n\n  update(key: string, value: string): void {\n    const [sideNodes, oldLeafHash, oldLeafData] = this.sideNodesForRoot(key, this.root);\n\n    let newRoot;\n    if (value === ZERO) {\n      newRoot = this.deleteWithSideNodes(key, sideNodes, oldLeafHash, oldLeafData);\n    } else {\n      newRoot = this.updateWithSideNodes(key, value, sideNodes, oldLeafHash, oldLeafData);\n    }\n\n    this.setRoot(newRoot);\n  }\n\n  delete(key: string): void {\n    this.update(key, ZERO);\n  }\n\n  prove(key: string): SparseMerkleProof {\n    const [sideNodes, leafHash, leafData, siblingData] = this.sideNodesForRoot(key, this.root);\n\n    const nonEmptySideNodes: string[] = [];\n\n    for (let i = 0; i < sideNodes.length; i += 1) {\n      if (sideNodes[i] !== '') {\n        nonEmptySideNodes.push(sideNodes[i]);\n      }\n    }\n\n    // Deal with non-membership proofs. If the leaf hash is the placeholder\n    // value, we do not need to add anything else to the proof.\n    let nonMembershipLeafData = '';\n    if (leafHash !== ZERO) {\n      const [actualPath] = parseLeaf(leafData);\n      if (actualPath !== key) {\n        // This is a non-membership proof that involves showing a different leaf.\n        // Add the leaf data to the proof.\n        nonMembershipLeafData = leafData;\n      }\n    }\n\n    const proof = new SparseMerkleProof(nonEmptySideNodes, nonMembershipLeafData, siblingData);\n    return proof;\n  }\n\n  proveCompacted(key: string): SparseCompactMerkleProof {\n    const proof = this.prove(key);\n    const compactedProof = compactProof(proof);\n    return compactedProof;\n  }\n}\n\nexport default SparseMerkleTree;\n","import { hash } from '@fuel-ts/merkle-shared';\n\nimport { hashLeaf, hashNode, parseLeaf } from './treeHasher';\nimport SparseCompactMerkleProof from './types/sparseCompactMerkleProof';\nimport SparseMerkleProof from './types/sparseMerkleProof';\nimport { getBitAtFromMSB, ZERO } from './utils';\n\n/**\n * Verify a merkle proof\n */\nexport function verifyProof(\n  proof: SparseMerkleProof,\n  root: string,\n  key: string,\n  value: string\n): [boolean, string[][]] {\n  const updates: string[][] = [[]];\n\n  // Detemine what the leaf hash should be\n  let currentHash;\n  let currentData;\n  let actualPath;\n  let valueHash;\n\n  if (value === ZERO) {\n    // Non-membership proof\n    if (proof.NonMembershipLeafData === '') {\n      currentHash = ZERO;\n    } else {\n      // leaf is an unrelated leaf\n      [actualPath, valueHash] = parseLeaf(proof.NonMembershipLeafData);\n      if (actualPath === key) {\n        // Leaf does exist : non-membership proof failed\n        return [false, []];\n      }\n      [currentHash, currentData] = hashLeaf(actualPath, valueHash);\n      updates.push([currentHash, currentData]);\n    }\n  } else {\n    // Membership proof\n    valueHash = hash(value);\n    updates.push([valueHash, value]);\n\n    [currentHash, currentData] = hashLeaf(key, value);\n    updates.push([currentHash, currentData]);\n  }\n\n  // Recompute root\n  for (let i = 0; i < proof.SideNodes.length; i += 1) {\n    const node = proof.SideNodes[i];\n\n    if (getBitAtFromMSB(key, proof.SideNodes.length - 1 - i) === 1) {\n      [currentHash, currentData] = hashNode(node, currentHash);\n    } else {\n      [currentHash, currentData] = hashNode(currentHash, node);\n    }\n\n    updates.push([currentHash, currentData]);\n  }\n\n  return [currentHash === root, updates];\n}\n\n/**\n * Compact a Sparse Merkle Proof using a bitmask\n */\nexport function compactProof(proof: SparseMerkleProof): SparseCompactMerkleProof {\n  const bitMask: number[] = [];\n  const compactedSideNodes: string[] = [];\n  let node;\n\n  for (let i = 0; i < proof.SideNodes.length; i += 1) {\n    node = proof.SideNodes[i];\n    if (node === ZERO) {\n      bitMask.push(0);\n    } else {\n      compactedSideNodes.push(node);\n      bitMask.push(1);\n    }\n  }\n  const compactedProof = new SparseCompactMerkleProof(\n    compactedSideNodes,\n    proof.NonMembershipLeafData,\n    bitMask,\n    proof.SideNodes.length,\n    proof.SiblingData\n  );\n  return compactedProof;\n}\n\n/**\n * Decompact a Sparse Merkle Proof\n */\nexport function decompactProof(proof: SparseCompactMerkleProof): SparseMerkleProof {\n  const decompactedSideNodes: string[] = [];\n  let position = 0;\n\n  for (let i = 0; i < proof.NumSideNodes; i += 1) {\n    if (proof.BitMask[i] === 0) {\n      decompactedSideNodes[i] = ZERO;\n    } else {\n      decompactedSideNodes[i] = proof.SideNodes[position];\n      position += 1;\n    }\n  }\n  const decompactedProof = new SparseMerkleProof(\n    decompactedSideNodes,\n    proof.NonMembershipLeafData,\n    proof.SiblingData\n  );\n\n  return decompactedProof;\n}\n","import { hash } from '@fuel-ts/merkle-shared';\n\nexport const leafPrefix = '0x00';\nexport const nodePrefix = '0x01';\n\n/**\n * Slice off the '0x' on each argument to simulate abi.encode\n * prefix + key + hash(data)\n */\nexport function hashLeaf(key: string, data: string): [string, string] {\n  const value = '0x00'.concat(key.slice(2)).concat(hash(data).slice(2));\n  return [hash(value), value];\n}\n\n/**\n * Slice off the '0x' on each argument to simulate abi.encodePacked\n * prefix + key + hash(data)\n */\nexport function hashNode(left: string, right: string): [string, string] {\n  const value = '0x01'.concat(left.slice(2)).concat(right.slice(2));\n  return [hash(value), value];\n}\n\n/**\n * Parse a leaf\n */\nexport function parseLeaf(data: string): [string, string] {\n  const len = nodePrefix.length;\n  return ['0x'.concat(data.slice(len, len + 64)), '0x'.concat(data.slice(len + 64))];\n}\n\n/**\n * Parse a nodes\n */\nexport function parseNode(data: string): [string, string] {\n  const len = nodePrefix.length;\n  return ['0x'.concat(data.slice(len, len + 64)), '0x'.concat(data.slice(len + 64))];\n}\n\n/**\n * Check if data is a leaf by checking prefix\n */\nexport function isLeaf(data: string): boolean {\n  return data.slice(0, 4) === leafPrefix;\n}\n","class SparseCompactMerkleProof {\n  SideNodes: string[];\n  NonMembershipLeafData: string;\n  BitMask: number[];\n  NumSideNodes: number;\n  SiblingData: string;\n\n  constructor(\n    SideNodes: string[],\n    NonMembershipLeafData: string,\n    Bitmask: number[],\n    NumSideNodes: number,\n    SiblingData: string\n  ) {\n    this.SideNodes = SideNodes;\n    this.NonMembershipLeafData = NonMembershipLeafData;\n    this.BitMask = Bitmask;\n    this.NumSideNodes = NumSideNodes;\n    this.SiblingData = SiblingData;\n  }\n}\n\nexport default SparseCompactMerkleProof;\n","// Sparse Merkle proof\nclass SparseMerkleProof {\n  SideNodes: string[];\n  NonMembershipLeafData: string;\n  SiblingData: string;\n\n  constructor(sideNodes: string[], NonMembershipLeafData: string, SiblingData: string) {\n    this.SideNodes = sideNodes;\n    this.NonMembershipLeafData = NonMembershipLeafData;\n    this.SiblingData = SiblingData;\n  }\n}\n\nexport default SparseMerkleProof;\n","export const ZERO = '0x0000000000000000000000000000000000000000000000000000000000000000';\nexport const EMPTY = '0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855';\nexport const MAX_HEIGHT = 256;\n\nexport interface MapStore {\n  [key: string]: string;\n}\n\n/**\n * Gets the bit at an offset from the most significant bit\n */\nexport function getBitAtFromMSB(data: string, position: number): number {\n  // if int(data[position / 8]) & (1 << (8 - 1 - uint(position) % 8)) > 0\n\n  // Slice off '0x'\n  const slicedData = data.slice(2);\n  // Get byte that contains the specified position\n  const byte = '0x'.concat(\n    slicedData.slice(Math.floor(position / 8) * 2, Math.floor(position / 8) * 2 + 2)\n  );\n  // Get bits from specified position within that byte\n  const bits = Number(byte) & (1 << (8 - 1 - (position % 8)));\n\n  // Bit at position = 0 IFF bits > 0.\n  if (bits > 0) {\n    return 1;\n  }\n  return 0;\n}\n/**\n * Reverse the nodes position\n */\nexport function reverseSideNodes(sideNodes: string[]): string[] {\n  let left = 0;\n  let right = sideNodes.length - 1;\n  const reversedSideNodes: string[] = sideNodes;\n\n  while (left < right) {\n    [reversedSideNodes[left], reversedSideNodes[right]] = [\n      reversedSideNodes[right],\n      reversedSideNodes[left],\n    ];\n    left += 1;\n    right -= 1;\n  }\n\n  return reversedSideNodes;\n}\n\n/**\n * Counts the common bit at at an offset from the most significant bit\n * between two inputs\n */\nexport function countCommonPrefix(data1: string, data2: string): number {\n  let count = 0;\n  for (let i = 0; i < MAX_HEIGHT; i += 1) {\n    if (getBitAtFromMSB(data1, i) === getBitAtFromMSB(data2, i)) {\n      count += 1;\n    } else {\n      break;\n    }\n  }\n  return count;\n}\n"],"mappings":"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","names":["hash","hash","hash","leafPrefix","nodePrefix","hashLeaf","key","data","value","hashNode","left","right","parseLeaf","len","parseNode","isLeaf","SparseCompactMerkleProof","SideNodes","NonMembershipLeafData","Bitmask","NumSideNodes","SiblingData","sparseCompactMerkleProof_default","SparseMerkleProof","sideNodes","NonMembershipLeafData","SiblingData","sparseMerkleProof_default","ZERO","getBitAtFromMSB","data","position","slicedData","byte","reverseSideNodes","sideNodes","left","right","reversedSideNodes","countCommonPrefix","data1","data2","count","i","compactProof","proof","bitMask","compactedSideNodes","node","i","ZERO","sparseCompactMerkleProof_default","SparseMerkleTree","ms","ZERO","key","value","root","sideNodes","currentData","isLeaf","leftNode","rightNode","nodeHash","sideNode","i","parseNode","getBitAtFromMSB","siblingData","reverseSideNodes","oldLeafHash","oldLeafData","actualPath","parseLeaf","currentHash","sideNodeValue","nonPlaceholderReached","hashNode","hash","hashLeaf","commonPrefixCount","countCommonPrefix","offsetOfSideNodes","newRoot","leafHash","leafData","nonEmptySideNodes","nonMembershipLeafData","sparseMerkleProof_default","proof","compactProof","sparseMerkleTree_default"]}