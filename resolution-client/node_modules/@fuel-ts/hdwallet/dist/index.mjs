import{Base58 as x}from"@ethersproject/basex";import{hexDataSlice as g,hexlify as i,concat as f,arrayify as h}from"@ethersproject/bytes";import{computeHmac as B,ripemd160 as A,sha256 as y,SupportedAlgorithm as L}from"@ethersproject/sha2";import{bn as U,toBytes as S,toHex as D}from"@fuel-ts/math";import{Mnemonic as R}from"@fuel-ts/mnemonic";import{Signer as m}from"@fuel-ts/signer";var v=2147483648,w=i("0x0488ade4"),l=i("0x0488b21e"),E=i("0x04358394"),u=i("0x043587cf");function b(n){return x.encode(f([n,g(y(y(n)),0,4)]))}function M(n=!1,e=!1){return n?e?u:l:e?E:w}function N(n){return[l,u].includes(i(n.slice(0,4)))}function V(n){return[w,E,l,u].includes(i(n.slice(0,4)))}function T(n,e=0){let t=n.split("/");if(t.length===0||t[0]==="m"&&e!==0)throw new Error(`invalid path - ${n}`);return t[0]==="m"&&t.shift(),t.map(r=>~r.indexOf("'")?parseInt(r,10)+v:parseInt(r,10))}var c=class{depth=0;index=0;fingerprint=i("0x00000000");parentFingerprint=i("0x00000000");privateKey;publicKey;chainCode;constructor(e){if(e.privateKey){let t=new m(e.privateKey);this.publicKey=i(t.compressedPublicKey),this.privateKey=i(e.privateKey)}else{if(!e.publicKey)throw new Error("Public and Private Key are missing!");this.publicKey=i(e.publicKey)}this.parentFingerprint=e.parentFingerprint||this.parentFingerprint,this.fingerprint=g(A(y(this.publicKey)),0,4),this.depth=e.depth||this.depth,this.index=e.index||this.index,this.chainCode=e.chainCode}get extendedKey(){return this.toExtendedKey()}deriveIndex(e){let t=this.privateKey&&h(this.privateKey),r=h(this.publicKey),s=h(this.chainCode),o=new Uint8Array(37);if(e&v){if(!t)throw new Error("Derive hardened requires privateKey");o.set(t,1)}else o.set(h(this.publicKey));o.set(S(e,4),33);let p=h(B(L.sha512,s,o)),d=p.slice(0,32),a=p.slice(32);if(t){let C="0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141",I=U(d).add(t).mod(C).toBytes(32);return new c({privateKey:I,chainCode:a,index:e,depth:this.depth+1,parentFingerprint:this.fingerprint})}let k=new m(i(d)).addPoint(r);return new c({publicKey:k,chainCode:a,index:e,depth:this.depth+1,parentFingerprint:this.fingerprint})}derivePath(e){return T(e,this.depth).reduce((r,s)=>r.deriveIndex(s),this)}toExtendedKey(e=!1,t=!1){if(this.depth>=256)throw new Error("Depth too large!");let r=M(this.privateKey==null||e,t),s=i(this.depth),o=this.parentFingerprint,p=D(this.index,4),d=this.chainCode,a=this.privateKey!=null&&!e?f(["0x00",this.privateKey]):this.publicKey,K=f([r,s,o,p,d,a]);return b(K)}static fromSeed(e){let t=R.masterKeysFromSeed(e);return new c({chainCode:h(t.slice(32)),privateKey:h(t.slice(0,32))})}static fromExtendedKey(e){let t=x.decode(e),r=b(t.slice(0,78))===e;if(t.length!==82||!V(t))throw new Error("Invalid extended key");if(!r)throw new Error("Invalid checksum key");let s=t[4],o=i(t.slice(5,9)),p=parseInt(i(t.slice(9,13)).substring(2),16),d=i(t.slice(13,45)),a=t.slice(45,78);if(s===0&&o!=="0x00000000"||s===0&&p!==0)throw new Error("Invalid depth");if(N(t)){if(a[0]!==3)throw new Error("Invalid public extended key");return new c({publicKey:a,chainCode:d,index:p,depth:s,parentFingerprint:o})}if(a[0]!==0)throw new Error("Invalid private extended key");return new c({privateKey:a.slice(1),chainCode:d,index:p,depth:s,parentFingerprint:o})}},j=c;export{j as HDWallet};
//# sourceMappingURL=index.mjs.map