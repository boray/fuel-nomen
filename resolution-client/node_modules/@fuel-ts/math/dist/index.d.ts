import BnJs from 'bn.js';

type BigNumberish = string | number | BN;
type ToFixedConfig = {
    minPrecision?: number;
    precision?: number;
};
type FormatConfig = {
    units?: number;
} & ToFixedConfig;

type CompareResult = -1 | 0 | 1;
type BNInput = number | string | number[] | Uint8Array | Buffer | BnJs;
interface BNHelper {
    caller(v: BNInput, methodName: string): BN | boolean | CompareResult;
    toHex: (bytesPadding?: number) => string;
    toBytes: (bytesPadding?: number) => Uint8Array;
    toJSON: () => string;
}
interface BNInputOverrides {
    add: (v: BNInput) => BN;
    pow: (v: BNInput) => BN;
    sub: (v: BNInput) => BN;
    div: (v: BNInput) => BN;
    mul: (v: BNInput) => BN;
    mod: (v: BNInput) => BN;
    divRound: (v: BNInput) => BN;
    lt: (v: BNInput) => boolean;
    lte: (v: BNInput) => boolean;
    gt: (v: BNInput) => boolean;
    gte: (v: BNInput) => boolean;
    eq: (v: BNInput) => boolean;
    cmp: (v: BNInput) => CompareResult;
}
interface BNOverrides {
    sqr: () => BN;
    neg: () => BN;
    abs: () => BN;
    toTwos: (width: number) => BN;
    fromTwos: (width: number) => BN;
}
interface BNHiddenTypes {
    mulTo: (num: BN, out: BN) => BN;
    divmod: (num: BNInput, mode?: string, positive?: boolean) => {
        mod: BN;
        div: BN;
    };
}
type BNInputOverridesKeys = keyof BNInputOverrides;
declare class BN extends BnJs implements BNInputOverrides, BNHiddenTypes, BNHelper, BNOverrides {
    constructor(value?: BNInput | null, base?: number | 'hex', endian?: BnJs.Endianness);
    toString(base?: number | 'hex', length?: number): string;
    toHex(bytesPadding?: number): string;
    toBytes(bytesPadding?: number): Uint8Array;
    toJSON(): string;
    valueOf(): string;
    format(options?: FormatConfig): string;
    formatUnits(units?: number): string;
    add(v: BNInput): BN;
    pow(v: BNInput): BN;
    sub(v: BNInput): BN;
    div(v: BNInput): BN;
    mul(v: BNInput): BN;
    mod(v: BNInput): BN;
    divRound(v: BNInput): BN;
    lt(v: BNInput): boolean;
    lte(v: BNInput): boolean;
    gt(v: BNInput): boolean;
    gte(v: BNInput): boolean;
    eq(v: BNInput): boolean;
    cmp(v: BNInput): CompareResult;
    sqr(): BN;
    neg(): BN;
    abs(): BN;
    toTwos(width: number): BN;
    fromTwos(width: number): BN;
    caller(v: BNInput, methodName: BNInputOverridesKeys): BN | boolean | CompareResult;
    clone(): BN;
    mulTo(num: BN, out: BN): BN;
    egcd(p: BnJs): {
        a: BN;
        b: BN;
        gcd: BN;
    };
    divmod(num: BNInput, mode?: string, positive?: boolean): {
        mod: BN;
        div: BN;
    };
}
declare const bn: {
    (value?: BNInput | null, base?: number | 'hex', endian?: BnJs.Endianness): BN;
    parseUnits(value: string, units?: number): BN;
};

declare function toFixed(value?: string | number, options?: ToFixedConfig): string;

/**
 * Functional shortcuts
 */
declare function toNumber(value: BNInput): number;
declare function toHex(value: BNInput, bytesPadding?: number): string;
declare function toBytes(value: BNInput, bytesPadding?: number): Uint8Array;
declare function formatUnits(value: BNInput, units?: number): string;
declare function format(value: BNInput, options?: FormatConfig): string;

declare function max(...numbers: Array<BigNumberish>): BN;
declare function multiply(...numbers: Array<BigNumberish>): BN;

export { BN, BNInput, BigNumberish, FormatConfig, ToFixedConfig, bn, format, formatUnits, max, multiply, toBytes, toFixed, toHex, toNumber };
