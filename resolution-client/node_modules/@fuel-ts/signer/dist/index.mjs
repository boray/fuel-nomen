import{concat as n,hexlify as c,arrayify as s}from"@ethersproject/bytes";import{Address as l}from"@fuel-ts/address";import{hash as p}from"@fuel-ts/hasher";import{randomBytes as u}from"@fuel-ts/keystore";import{toBytes as d}from"@fuel-ts/math";import*as b from"elliptic";var{ec:k}=b;function o(){return new k("secp256k1")}var a=class{address;publicKey;compressedPublicKey;privateKey;constructor(e){typeof e=="string"&&e.match(/^[0-9a-f]*$/i)&&e.length===64&&(e=`0x${e}`);let r=s(e),t=o().keyFromPrivate(r,"hex");this.compressedPublicKey=c(t.getPublic(!0,"array")),this.publicKey=c(t.getPublic(!1,"array").slice(1)),this.privateKey=c(r),this.address=l.fromPublicKey(this.publicKey)}sign(e){let t=o().keyFromPrivate(s(this.privateKey),"hex").sign(s(e),{canonical:!0}),y=d(t.r,32),i=d(t.s,32);return i[0]|=(t.recoveryParam||0)<<7,c(n([y,i]))}addPoint(e){let r=o().keyFromPublic(s(this.compressedPublicKey)),t=o().keyFromPublic(s(e)),y=r.getPublic().add(t.getPublic());return c(y.encode("array",!0))}static recoverPublicKey(e,r){let t=s(r),y=t.slice(0,32),i=t.slice(32,64),m=(i[0]&128)>>7;return i[0]&=127,o().recoverPubKey(s(e),{r:y,s:i},m).encode("array",!1).slice(1)}static recoverAddress(e,r){return l.fromPublicKey(a.recoverPublicKey(e,r))}static generatePrivateKey(e){return e?p(n([u(32),s(e)])):u(32)}static extendPublicKey(e){let r=o().keyFromPublic(s(e));return c(r.getPublic(!1,"array").slice(1))}},g=a;export{g as Signer,o as getCurve};
//# sourceMappingURL=index.mjs.map