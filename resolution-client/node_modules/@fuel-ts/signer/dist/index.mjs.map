{"version":3,"sources":["../src/signer.ts"],"sourcesContent":["import type { BytesLike } from '@ethersproject/bytes';\nimport { concat, hexlify, arrayify } from '@ethersproject/bytes';\nimport { Address } from '@fuel-ts/address';\nimport { hash } from '@fuel-ts/hasher';\nimport { randomBytes } from '@fuel-ts/keystore';\nimport { toBytes } from '@fuel-ts/math';\nimport * as elliptic from 'elliptic';\n\n/* Importing `ec` like this to avoid the 'Requested module is a CommonJS module,\n * which may not support all module.exports as named exports' error\n * @see https://github.com/FuelLabs/fuels-ts/issues/841\n */\nconst { ec: EC } = elliptic;\n\n/**\n * Return elliptic instance with curve secp256k1\n */\nexport function getCurve() {\n  return new EC('secp256k1');\n}\n\nclass Signer {\n  readonly address: Address;\n\n  readonly publicKey: string;\n\n  readonly compressedPublicKey: string;\n\n  readonly privateKey: string;\n\n  /**\n   * Create a Signer instance from a given private key\n   *\n   * @param privateKey - The private key to use for signing\n   * @returns A new Signer instance\n   */\n  constructor(privateKey: BytesLike) {\n    // A lot of common tools do not prefix private keys with a 0x\n    if (typeof privateKey === 'string') {\n      if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {\n        // eslint-disable-next-line no-param-reassign\n        privateKey = `0x${privateKey}`;\n      }\n    }\n\n    // Convert to byte array, normalize private key input allowing it to be BytesLike\n    // like remove 0x prefix and accept array of bytes\n    const privateKeyBytes = arrayify(privateKey);\n    const keyPair = getCurve().keyFromPrivate(privateKeyBytes, 'hex');\n\n    // Slice(1) removes the encoding scheme from the public key\n    this.compressedPublicKey = hexlify(keyPair.getPublic(true, 'array'));\n    this.publicKey = hexlify(keyPair.getPublic(false, 'array').slice(1));\n    this.privateKey = hexlify(privateKeyBytes);\n    this.address = Address.fromPublicKey(this.publicKey);\n  }\n\n  /**\n   * Sign data using the Signer instance\n   *\n   * Signature is a 64 byte array of the concatenated r and s values with the compressed recoveryParam byte. [Read more](FuelLabs/fuel-specs/specs/protocol/cryptographic_primitives.md#public-key-cryptography)\n   *\n   * @param data - The data to be sign\n   * @returns hashed signature\n   */\n  sign(data: BytesLike) {\n    const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey), 'hex');\n    const signature = keyPair.sign(arrayify(data), {\n      canonical: true,\n    });\n    const r = toBytes(signature.r, 32);\n    const s = toBytes(signature.s, 32);\n\n    // add recoveryParam to first s byte\n    s[0] |= (signature.recoveryParam || 0) << 7;\n\n    return hexlify(concat([r, s]));\n  }\n\n  /**\n   * Add point on the current elliptic curve\n   *\n   * @param point - Point to add on the curve\n   * @returns compressed point on the curve\n   */\n  addPoint(point: BytesLike) {\n    const p0 = getCurve().keyFromPublic(arrayify(this.compressedPublicKey));\n    const p1 = getCurve().keyFromPublic(arrayify(point));\n    const result = p0.getPublic().add(p1.getPublic());\n\n    return hexlify(result.encode('array', true));\n  }\n\n  /**\n   * Recover the public key from a signature performed with [`sign`](#sign).\n   *\n   * @param data - Data\n   * @param signature - hashed signature\n   * @returns public key from signature from the\n   */\n  static recoverPublicKey(data: BytesLike, signature: BytesLike) {\n    const signedMessageBytes = arrayify(signature);\n    const r = signedMessageBytes.slice(0, 32);\n    const s = signedMessageBytes.slice(32, 64);\n    const recoveryParam = (s[0] & 0x80) >> 7;\n\n    // remove recoveryParam from s first byte\n    s[0] &= 0x7f;\n\n    const publicKey = getCurve()\n      .recoverPubKey(arrayify(data), { r, s }, recoveryParam)\n      .encode('array', false)\n      .slice(1);\n\n    return publicKey;\n  }\n\n  /**\n   * Recover the address from a signature performed with [`sign`](#sign).\n   *\n   * @param data - Data\n   * @param signature - Signature\n   * @returns Address from signature\n   */\n  static recoverAddress(data: BytesLike, signature: BytesLike): Address {\n    return Address.fromPublicKey(Signer.recoverPublicKey(data, signature));\n  }\n\n  /**\n   * Generate a random privateKey\n   *\n   * @param entropy - Adds extra entropy to generate the privateKey\n   * @returns random 32-byte hashed\n   */\n  static generatePrivateKey(entropy?: BytesLike) {\n    return entropy ? hash(concat([randomBytes(32), arrayify(entropy)])) : randomBytes(32);\n  }\n\n  /**\n   * Extended publicKey from a compact publicKey\n   *\n   * @param publicKey - Compact publicKey\n   * @returns extended publicKey\n   */\n  static extendPublicKey(publicKey: BytesLike) {\n    const keyPair = getCurve().keyFromPublic(arrayify(publicKey));\n    return hexlify(keyPair.getPublic(false, 'array').slice(1));\n  }\n}\n\nexport default Signer;\n"],"mappings":"AACA,OAAS,UAAAA,EAAQ,WAAAC,EAAS,YAAAC,MAAgB,uBAC1C,OAAS,WAAAC,MAAe,mBACxB,OAAS,QAAAC,MAAY,kBACrB,OAAS,eAAAC,MAAmB,oBAC5B,OAAS,WAAAC,MAAe,gBACxB,UAAYC,MAAc,WAM1B,GAAM,CAAE,GAAIC,CAAG,EAAID,EAKZ,SAASE,GAAW,CACzB,OAAO,IAAID,EAAG,WAAW,CAC3B,CAEA,IAAME,EAAN,KAAa,CACF,QAEA,UAEA,oBAEA,WAQT,YAAYC,EAAuB,CAE7B,OAAOA,GAAe,UACpBA,EAAW,MAAM,cAAc,GAAKA,EAAW,SAAW,KAE5DA,EAAa,KAAKA,KAMtB,IAAMC,EAAkBV,EAASS,CAAU,EACrCE,EAAUJ,EAAS,EAAE,eAAeG,EAAiB,KAAK,EAGhE,KAAK,oBAAsBX,EAAQY,EAAQ,UAAU,GAAM,OAAO,CAAC,EACnE,KAAK,UAAYZ,EAAQY,EAAQ,UAAU,GAAO,OAAO,EAAE,MAAM,CAAC,CAAC,EACnE,KAAK,WAAaZ,EAAQW,CAAe,EACzC,KAAK,QAAUT,EAAQ,cAAc,KAAK,SAAS,CACrD,CAUA,KAAKW,EAAiB,CAEpB,IAAMC,EADUN,EAAS,EAAE,eAAeP,EAAS,KAAK,UAAU,EAAG,KAAK,EAChD,KAAKA,EAASY,CAAI,EAAG,CAC7C,UAAW,EACb,CAAC,EACKE,EAAIV,EAAQS,EAAU,EAAG,EAAE,EAC3BE,EAAIX,EAAQS,EAAU,EAAG,EAAE,EAGjC,OAAAE,EAAE,KAAOF,EAAU,eAAiB,IAAM,EAEnCd,EAAQD,EAAO,CAACgB,EAAGC,CAAC,CAAC,CAAC,CAC/B,CAQA,SAASC,EAAkB,CACzB,IAAMC,EAAKV,EAAS,EAAE,cAAcP,EAAS,KAAK,mBAAmB,CAAC,EAChEkB,EAAKX,EAAS,EAAE,cAAcP,EAASgB,CAAK,CAAC,EAC7CG,EAASF,EAAG,UAAU,EAAE,IAAIC,EAAG,UAAU,CAAC,EAEhD,OAAOnB,EAAQoB,EAAO,OAAO,QAAS,EAAI,CAAC,CAC7C,CASA,OAAO,iBAAiBP,EAAiBC,EAAsB,CAC7D,IAAMO,EAAqBpB,EAASa,CAAS,EACvCC,EAAIM,EAAmB,MAAM,EAAG,EAAE,EAClCL,EAAIK,EAAmB,MAAM,GAAI,EAAE,EACnCC,GAAiBN,EAAE,GAAK,MAAS,EAGvC,OAAAA,EAAE,IAAM,IAEUR,EAAS,EACxB,cAAcP,EAASY,CAAI,EAAG,CAAE,EAAAE,EAAG,EAAAC,CAAE,EAAGM,CAAa,EACrD,OAAO,QAAS,EAAK,EACrB,MAAM,CAAC,CAGZ,CASA,OAAO,eAAeT,EAAiBC,EAA+B,CACpE,OAAOZ,EAAQ,cAAcO,EAAO,iBAAiBI,EAAMC,CAAS,CAAC,CACvE,CAQA,OAAO,mBAAmBS,EAAqB,CAC7C,OAAOA,EAAUpB,EAAKJ,EAAO,CAACK,EAAY,EAAE,EAAGH,EAASsB,CAAO,CAAC,CAAC,CAAC,EAAInB,EAAY,EAAE,CACtF,CAQA,OAAO,gBAAgBoB,EAAsB,CAC3C,IAAMZ,EAAUJ,EAAS,EAAE,cAAcP,EAASuB,CAAS,CAAC,EAC5D,OAAOxB,EAAQY,EAAQ,UAAU,GAAO,OAAO,EAAE,MAAM,CAAC,CAAC,CAC3D,CACF,EAEOa,EAAQhB","names":["concat","hexlify","arrayify","Address","hash","randomBytes","toBytes","elliptic","EC","getCurve","Signer","privateKey","privateKeyBytes","keyPair","data","signature","r","s","point","p0","p1","result","signedMessageBytes","recoveryParam","entropy","publicKey","signer_default"]}